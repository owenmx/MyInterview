# 面向对象的三条主线

**上：**java类以及类的成员：属性、方法、构造器、代码块、内部类

**中：**面向对象的三大特征：封装、继承、多态、（抽象性）

**下：**其他关键字：this、super、static、final、ab stract、interface、package、import等



#### 面向对象的三大特性

面向对象具有封装、继承。多态三大特性

封装：将类的某些信息（属性和方法）隐藏在类的内部，不允许外部程序直接访问。

继承：子类继承父类的特征和行为，使得子类对象具有和父类对象相同的特征和方法。

<img src="../../\LeetCode刷题\images\1646504-20190402192858436-1066053470.png" alt="img" style="zoom:67%;" />

多态：同一个行为具有多个不同的表现形式或形态的能力。

基本设计思路：实际生活中的对象$\rightarrow$ 现实生活中的类$\rightarrow$程序代码中的类$\rightarrow$程序代码中的对象



## 类和对象

什么是**类**：类是描述了一组具有相同属性和相同行为的一组对象的集合。类是构造面向对象程序的基本单位。

什么是**属性=成员变量=field**：对象或实体所拥有的特征在类中表示时称为类的属性。

什么是**行为=成员方法=method**：对象执行的操作称为类的方法。



#### 对象的JVM内存解析

<img src="../../\LeetCode刷题\images\image-20210419150208946.png" alt="image-20210419150208946" style="zoom: 50%;" />

+   **堆**，此内存区域的唯一目的就是存放对象实例（实例对象、数组），所有的对象实例都在这里分配内存，在 Java虚拟机规范中：所有的对象实例以及数组都要在堆上分配。
+   **栈**，虚拟机栈由于存放局部变量，包括基本数据类型（8种基本数据类型）、对象引用（reference类型，它不同于对象本身，是对象在堆内存放的首地址，比如下图的p1:0x12ab）。方法执行完就释放。
+   **方法区**，用于存放已被虚拟机加载的类信息、常量和静态变量以及编译后的代码。

<img src="../../\LeetCode刷题\images\image-20210419151819549.png" alt="image-20210419151819549" style="zoom: 67%;" />

#### 属性与局部变量

局部变量：形参，方法内部定义的变量，代码块内，构造器形参，构造器内部的变量

局部变量是加载到栈空间中，非static的属性变量加载到堆空间中。

```java
public void talk(String val) { // val 局部变量
    String food; // 局部变量
    System.out.println(food); 
}
```



#### 方法

基本的结构类型：

```java
// [权限修饰符] [关键字] [返回类型] [方法名] (参数) {
//    函数体
// }

[public|private|protected] [static|abstract|final] [void|String|...] method_name(参数) {
    
}
```



## 封装

#### 权限修饰符

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
| :---------- | :----- | :------- | :------------- | :----------------------------------------------------------- | :----- |
| `public`    | Y      | Y        | Y              | Y                                                            | Y      |
| `protected` | Y      | Y        | Y              | Y/N（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） |        |
| `default`   | Y      | Y        | Y              |                                                              |        |
| `private`   | Y      |          |                |                                                              |        |



## 多态

#### 重载

在一个类中，存在一个以上的同名方法，就是同一个方法有不同的表现形式。



#### 重写

继承的过程中，在子类中重写父类的方法。

+   1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
+   2、同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
+   3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。



## MVC 设计模式

#### 模型层

+   数据库对象封装 model.javabean

+   数据库操作类 model.dao

+   数据库 model.db

#### 控制层

+   应用界面相关 controller.activity
+   存放fragment controller.fragment 

#### 视图层

+   相关工具类 view.utils
+   自定义view view.ui

#### 总结

-   **Model（模型）** - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
-   **View（视图）** - 视图代表模型包含的数据的可视化。
-   **Controller（控制器）** - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。

## MVVM ~ Model View ViewModel

即模型-视图-视图模型，【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。

#### MVC和MVVM之间的区别 [🔗](https://www.php.cn/faq/417707.html)

+   1、`mvvm`各部分的通信是双向的，而`mvc`各部分通信是单向的；
+   2、`mvvm`是真正将页面与数据逻辑分离放到`js`里去实现，而`mvc`里面未分离;

## 杂项

#### 关于Java静态导入

使用静态导入可以使得被导入类的`静态变量`和`静态方法`在当前类**直接可见**，而不用再给出他们的类名。

导入指定类或者接口中的静态结构的（属性或者方法）。比如

```java
import static java.lang.System.*;

System.out.println("Hello");
// -->
out.println("123");
```

而import导入的类或者接口，import static导入的是属性或者方法。



#### 关于package

1.  为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。
2.  没“.”一次 就代表一层文件目录，比如`com.anguigu.data`就会创建三级目录





#### 关于this和super

在同一个上下文里，this 和 super 都是同一个对象的引用，也就是说指向同一个地址。区别在于，this 的类型是子类，而 super 的类型是父类。在访问父类非 private 成员的时候，获取到的值都是一样的，因为访问的都是内存里的同一个位置。而当在访问父类非 private 的方法（被子类覆盖的方法）的时候，this 会访问子类的方法，而 super 会访问父类的方法。

this是自身的一个对象，代表对象本身，可以理解为指向对象本身的一个指针。
super是一个java关键字，可以认为是自己超类对象的一个指针，而这个超类指的是离自己最近的一个父类。



#### 关于java的堆与栈

这里说的堆栈是指内存的两种组织形式，堆是指动态分配内存的一块区域，一般由程序员手动分配，比如 Java 中的 `new`、C/C++ 中的 `malloc` 等，都是将创建的对象或者内存块放置在堆区。

而栈是则是由编译器自动分配释放（大概就是你申明一个变量就分配一块相应大小的内存），用存放函数的参数值，局部变量等。



#### 关于对象数组

数组数据肯定是放在堆上的，栈上值保留了第一个元素的地址偏移地址。

对象数组就是自己定义了一个对象，然后构建了一个基于这个对象的数组。

当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。

![image-20210421164136880](../../\LeetCode刷题\images\image-20210421164136880.png)





#### 关于Java 匿名对象

匿名对象是存放在堆空间中的

```java
new Person().eat();
```



#### 关于Object类

万事万物皆对象

Object是java类库中的一个特殊类，是所有类的父亲，任何对象都可以调用Object类的方法。

| 方法                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| Object clone()         | 创建与该对象的类相同的新对象                                 |
| boolean equals(Object) | 比较两对象是否相等                                           |
| void finalize()        | 当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法 |
| Class getClass()       | 返回一个对象运行时的实例类                                   |
| int hashCode()         | 返回该对象的散列码值                                         |
| void notify()          | 激活等待在该对象的监视器上的一个线程                         |
| void notifyAll()       | 激活等待在该对象的监视器上的全部线程                         |
| String toString()      | 返回该对象的字符串表示                                       |
| void wait()            | 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待 |

