## 进程和线程

1.  进程是资源分配的基本单位

+   进程控制块PCB是描述进程的基本信息和运行状态，所谓创建进程和撤销进程是对PCB的操作。

+   线程是独立调度的基本单位，线程（私有地址空间，堆，全局变量，栈，寄存器；共享：代码段，公共数据，进程目录，进程ID）

+   进程调度算法：1.先来先服务，2.短作业优先，3.最短剩余时间优先；1.时间片轮转 2.优先级调度 3. 多级反馈队列

    

## 进程同步

1.  临界区

对临界资源进行访问的区域称为临界区。

2.  同步与互斥 🚀

同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系

互斥：多个进程在同一时刻只有一个进程能进入临界区

3.  信号量

信号量是一个整型变量，可以对其执行down和up操作，也就是常见的P和V操作

4.  生产者-消费者问题 

生产者和消费者在同一时间段内共用同一个存储空间，生产者向空间里存放数据，而消费者取用数据

```c++
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

5.  哲学家进餐问题 🚀 解决方案：同时拿起左边和右边的筷子，并且左边和右边都不在吃饭。
6.  读者-写者问题，不允许读写以及写写操作。设置两个心好累，count_mutex和data_mutex，用来控制读写。

### 进程通信

1.  注意区分进程同步和进程通信
2.  管道通信，fd[0]用于读，fd[1]用于写信息；只能在兄弟进程中和父子进程中进行通信
3.  消息队列，有写权限的进程可以向消息队列中添加新消息；有读权限的进程则可以从消息队列中读走消
4.  信号量通信
5.  共享存储通信
6.  套接字通信 不同机器间的通信



#### [进程和线程](https://www.jianshu.com/p/2dc01727be45)

-   区别：
    -   进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）
    -   进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
    -   线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
    -   但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
-   进程与线程的资源
    -   线程共享：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。
    -   线程独有：栈（保存其运行状态和局部自动变量）、程序计数器。
-   进程与线程的同步
    -   进程：无名管道、有名管道、信号、共享内存、消息队列、信号量
    -   线程：互斥量、读写锁、自旋锁、线程信号、条件变量
-   僵尸进程
    -   定义：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或者waitpid获取子进程的状态信息，那么子进程的进程描述符等一系列信息还会保存在系统中。这种进程称之为僵死进程。
    -   危害：在Unix系统管理中，当用ps命令观察进程的执行状态时，经常看到某些进程的状态栏为defunct，这就是所谓的“僵尸”进程。“僵尸”进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。由于进程表的容量是有限的，所以，defunct进程不仅占用系统的内存资源，影响系统的性能，而且如果其数目太多，还会导致系统瘫痪。
    -   处理方法：
        -   改写父进程，在子进程死后要为它收尸。具体做法是接管SIGCHLD信号。子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子进程收尸。这是基于这样的原理：就算父进程没有调用wait，内核也会向它发送SIGCHLD消息，尽管默认处理是忽略，如果想响应这个消息，可以设置一个处理函数。
        -   把父进程杀掉。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。
-   孤儿进程
    -   父进程运行结束，但子进程还在运行(未运行结束)的子进程就称为孤儿进程。孤儿进程最终会被init进程(进程号为1)所收养，因此init进程此时变成孤儿进程的父进程，并由init进程对它们完成状态收集工作。（linux下，init是内核启动的第一个用户级进程，init有许多很重要的任务，比如像启动getty（用于用户登录）、实现运行级别、以及处理孤立进程。）

#### 进程、线程、协程

协程是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理。

+   协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态，比如yield。
+   线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
+   协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。

![image-20210726204134381](../../LeetCode刷题/images/image-20210726204134381.png)

