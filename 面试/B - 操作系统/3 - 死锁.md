### 产生死锁的必要条件

+   **互斥**
+   **占有和等待**
+   **不可抢占**
+   **环路等待**

-   互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
-   占有和等待：已经得到了某个资源的进程可以再请求新的资源。
-   不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
-   环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

### 处理方法

+   1 鸵鸟策略 （不处理）
+   2 死锁检测和死锁恢复
    +   检测： 就转变为图论中**有向图的环判断问题**. 而该问题, 可以借助成熟的**拓扑遍历算法**
    +   恢复：利用**抢占恢复**；利用**回滚恢复**；利用**杀死进程恢复**。
+   3 死锁预防 - **在程序运行之前**，破坏上面的四种必要条件
    +   破坏互斥条件
    +   破环占有和等待
    +   破坏不可抢占
    +   破坏环路等待
+   4 死锁避免 - 在程序运行时避免发生死锁
    +   安全状态
    +   单个资源的**银行家算法**
        +   数据结构：
            +   可用资源向量 available
            +   最大需求矩阵 max，记录每个进程对各类资源的最大需求量
            +   分配矩阵 allocation，记录每个进程对各类资源当前的占有量
            +   需求矩阵 need，记录每个进程对各类资源尚需要的数目
            +   请求向量 request，某个进程对各类资源的申请量
    +   多个资源的银行家算法



https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81.md#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2

