整体重要的内容：

+ 1. **内存的分配和回收**
+ 2. **逻辑内存的扩充**
+ 3. **虚拟地址和逻辑地址的转换**
+ 4. 内存保护

#### 1. 早期的内存分配机制 [基本介绍](https://www.cnblogs.com/myseries/p/12487211.html)  [高质量](https://blog.betacat.io/post/introduction-to-paging/)

早期的计算机中，要运行一个程序，会将程序全部装入内存中，程序直接运行在内存上。

存在的问题：**1. 进程地址空间不隔离**，造成安全问题；**2. 内存使用效率低下**；**3.地址空间不确定。**

#### 2. 分段

增加一个中间层，利用一种间接的地址访问方法去访问物理内存，从而实现地址隔离的目的。

当创建一个进程时，操作系统会为进程分配一个4GB大小的**虚拟进程空间**。与虚拟空间相对应的还有一个物理地址空间，这个地址空间对应的是真是的物理内存。

分段解决了问题1和问题3，但是内存使用效率仍然没有解决，每次换入换出的内存都是整个程序，会造成大量的磁盘访问操作。



#### 2.1 虚拟进程空间划分

![Virtual address space in the context of programming - Stack Overflow](../../\LeetCode刷题\images\data.png)

并且堆区分配一般从低地址到高地址分配，而栈区分配一般从高地址到低地址分配

`它存在，你能看的见，它是物理的`
`它存在，你看不见，它是透明的`
`它不存在，你却看得见，它是虚拟的`
`它不存在，你也看不见，他被删除了`

#### 2.2 虚拟内存与虚拟进程空间的区别

虚拟内存的含义是指内存可以存放在不同的地方，一些可以放在磁盘上，另外一些可以放在主存中。

虚拟进程空间指的是每个进程会被分配同样大小的虚拟进程空间，而这些进程空间可以映射到同一物理空间中。



### 3. 分页

分页的基本方法是将地址空间分成许多的页面，分页的思想就是程序运行时用到哪页就为哪页，没有用到的页暂时保留在硬盘上，当用到的页面在物理空间中时，将会触发`缺页中断`，利用页置换算法，将物理空间的页面置换到内存中。

这种映射锁需要的数据结构是页目和页表。

#### 分页地址映射

一个虚拟地址分成两个部分，一部分`存储页面号`，一部分`存储偏移量`。

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。`输入是虚拟地址，输出是物理地址。`

![img](../../LeetCode刷题/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63663433383661312d353863392d346563612d613137662d6531326231653937373065622e706e67)

### 4. 页表

分页使用一个名为*页表（page table）* 的结构来存储它的映射信息。

![paging-page-tables](../../\LeetCode刷题\images\paging-page-tables.svg)



### 5. 多级页表

我们刚才看到的那个简单的页表存在一个问题：在较大的地址空间中它会浪费内存。例如，假设一个进程使用4个虚拟页面`0`、`1_000_000`、`1_000_050`和`1_000_100`(这里的`_`表示千位分隔符):

![single-level-page-table](../../\LeetCode刷题\images\single-level-page-table.svg)

它只需要4个物理帧，但是页表中有超过100万个项目。而且我们还不能省略空项目，因为这样的话在地址转换的过程中，CPU就不能直接跳转到正确的页表项（例如，不能保证第四页就在页表的第四位）。

为了减少内存的浪费，我们可以使用一个**二级页表**。这里的第二级页表包含的是内存地址区间跟第一级页表的映射信息。

![multilevel-page-table](../../\LeetCode刷题\images\multilevel-page-table.svg)



### 6. 页面置换算法

+   LRU
+   NRU，每个页面有两个状态为：R与M，当页面被访问时，R=1，当页面被修改时，M=1。
+   FIFO
+   FIFO二次机会
+   Clock



#### 内存泄露和内存溢出

**内存泄露**：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。

**内存溢出**：申请的内存超出了虚拟机能提供的内存大小，此时称之为溢出。