#### åˆ†ç±»

+   æ‹“æ‰‘æ’åº

    +   æ‹“æ‰‘æ’åºï¼Œ207 è¯¾ç¨‹è¡¨

    



+   è¿é€šå›¾
    +   å¦‚ä½•å»ºå›¾å¹¶æ±‚è¿é€šå›¾çš„æ•°é‡ï¼Œ765 æƒ…ä¾£ç‰µæ‰‹ 
    +   æ±‚è¿é€šå›¾çš„æ•°é‡ï¼Œ547. çœä»½æ•°é‡



+   å¹¶æŸ¥é›†
    +   NC159 æœ€å°ç”Ÿæˆæ ‘
    +   654 å†—ä½™è¿æ¥



## æœ€çŸ­è·¯å¾„é—®é¢˜



#### Floyd å¤šæºæœ€çŸ­è·¯å¾„ [ğŸ°](https://www.youtube.com/watch?v=4NQ3HnhyNfQ)

$$
f[k][i][j] = \min\{f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]\}
$$

>   ![image-20210903123954817](images/image-20210903123954817.png)
>
>   $k$ æ¯å¢åŠ ä¸€ä¸ªï¼Œå°±ä»£è¡¨å¼•å…¥äº†æ–°çš„èŠ‚ç‚¹ï¼š
>
>   ![image-20210903144914543](images/image-20210903144914543.png)

```python
INF = float("inf")
graph = [
    [0  ,   2,  6,  4],
    [INF,   0,  3,INF],
    [  7, INF,  0,  1],
    [  5, INF, 12,  0]
]
def floyd(graph,start,target):
    n = len(graph)
    dp = [[graph[i][j] for j in range(n)] for i in range(n)]
    path = [[j for j in range(n)] for i in range(n)] 
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dp[i][j] > dp[i][k] + dp[k][j]:
                    dp[i][j] = dp[i][k] + dp[k][j]
                    path[i][j] = path[i][k]
    
    cur = start
    ans = [str(cur+1)]
    while cur != target:
        cur = path[cur][target]
        ans.append(str(cur+1))
    print("short path from {} to {} : {}".format(start+1,target+1,"->".join(ans)))
    print("value: {}".format(dp[start][target]))
floyd(graph,start=1,target=3)
```

#### Dijistraå•æºæœ€çŸ­è·¯å¾„ [ğŸ°](https://www.youtube.com/watch?v=pSqmAO-m7Lk)

```python
INF = float("inf")
graph = [
    [0,    1, 12,INF,INF,INF],
    [INF,  0,  9,  3,INF,INF],
    [INF,INF,  0,INF,  5,INF],
    [INF,INF,  4,  0, 13, 15],
    [INF,INF,INF,INF,  0,  4],
    [INF,INF,INF,INF,INF,  0]
]

def djikstra(graph,start):
    n = len(graph)
    dist = graph[start][:]
    visited = [False]*n
    visited[start] = True
    
    neighbor = collections.defaultdict(list)
    for i in range(n):
        for j in range(n): 
            if graph[i][j] != INF and graph[i][j] != 0:
                neighbor[i].append(j)
    
    size = 1
    while size <= n:
        # æ ¹æ®visitedé›†åˆï¼Œæ›´æ–°distæ•°ç»„
        for v in range(n):
            if visited[v]:
                for nxt in neighbor[v]:
                    dist[nxt] = min(dist[nxt],dist[v]+graph[v][nxt])

        # æ‰¾åˆ°è·ç¦»visitedé›†åˆæœ€è¿‘çš„èŠ‚ç‚¹
        idx = -1
        min_dist = float("inf")
        for v in range(n):
            if not visited[v] and min_dist > dist[v]:
                idx = v
                min_dist = dist[v]
        
        if idx == -1: break
        # å°†æœ€è¿‘èŠ‚ç‚¹åŠ å…¥visitedé›†åˆ
        visited[idx] = True
        size += 1
    
    return dist

djikstra(graph,0)
```





#### NC159 æœ€å°ç”Ÿæˆæ ‘ ğŸ‰

>   ![image-20210728181502025](images/image-20210728181502025.png)

![image-20210728181415131](images/image-20210728181415131-1627467256531.png)

```python
#
# ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
#
# è¿”å›æœ€å°çš„èŠ±è´¹ä»£ä»·ä½¿å¾—è¿™næˆ·äººå®¶è¿æ¥èµ·æ¥
# @param n int næˆ·äººå®¶çš„æ‘åº„
# @param m int mæ¡è·¯
# @param cost intäºŒç»´æ•°ç»„ ä¸€ç»´3ä¸ªå‚æ•°ï¼Œè¡¨ç¤ºè¿æ¥1ä¸ªæ‘åº„åˆ°å¦å¤–1ä¸ªæ‘åº„çš„èŠ±è´¹çš„ä»£ä»·
# @return int


# å¯¹äºéå†è¿‡ç¨‹çš„æ¯æ¡è¾¹ï¼Œå…¶éƒ½æœ‰ä¸¤ä¸ªé¡¶ç‚¹ï¼Œåˆ¤æ–­è¿™ä¸¤ä¸ªé¡¶ç‚¹çš„æ ‡è®°æ˜¯å¦ä¸€è‡´ï¼Œå¦‚æœä¸€è‡´ï¼Œè¯´æ˜å®ƒä»¬æœ¬èº«å°±å¤„åœ¨ä¸€æ£µæ ‘

class Solution:
    def miniSpanningTree(self , n , m , cost ):
        # é¦–å…ˆå¯¹æ‰€æœ‰èŠ‚ç‚¹è¿›è¡Œæ’åºï¼ŒæŒ‰ç…§è¾¹çš„æƒé‡ä»ä½åˆ°é«˜
        cost = sorted(cost, key=lambda x:x[2])
        # å®šä¹‰æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ˆé¡¶çº§æºèŠ‚ç‚¹ï¼‰
        father = {point:point for point in range(1, n+1)}
        res, sums = [], 0
        
        # ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä»¥åŠå¯¹åº”çš„èŠ±è´¹
        for u, v, w in cost:
            print(father,"\n")
            # ä¸¤ä¸ªèŠ‚ç‚¹çš„é¡¶çº§æºèŠ‚ç‚¹ä¸ç›¸åŒï¼Œè¯´æ˜æ²¡æœ‰è¿æ¥åœ¨ä¸€èµ·
            if father[u] != father[v]:
                # ç°åœ¨å°†ä»–ä»¬è¿æ¥åœ¨ä¸€èµ·ï¼Œfather[v]çš„çˆ¶äº²
                res.append([u, v, w])
                end = father[v] # å½“å‰vèŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹
                for point in range(1, n+1):
                    if father[point] == end: 
                        # å¦‚æœæŸä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹ç­‰äºvèŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹
                        # æ¯”å¦‚å½“å‰èŠ‚ç‚¹ä»¥åŠå’Œä»–æ‹¥æœ‰ç›¸åŒçˆ¶äº²èŠ‚ç‚¹çš„èŠ‚ç‚¹éƒ½ä¼šè¢«è¿æ¥èµ·æ¥
                        father[point] = father[u]
                sums += w
                if len(res) == n-1:
                    print(res)
                    return sums
        return sums
```





#### 943 æœ€çŸ­è¶…çº§ä¸² ğŸ‰

>   ![image-20210725164437524](images/image-20210725164437524.png)
>
>   **æ—…è¡Œå•†é—®é¢˜**ï¼Œæ•°ä½DPï¼Œè¿›è¡Œ`çŠ¶æ€å‹ç¼©`

```python
class Solution {
    /**
     * ç±»ä¼¼çš„æ€æƒ³å°±æ˜¯TSPé—®é¢˜ã€‚
     * dp[s][i] è¡¨ç¤ºçŠ¶æ€ä¸ºsï¼Œå¹¶ä»¥içŠ¶æ€ä¸ºç»“å°¾çš„æœ€çŸ­é•¿åº¦ã€‚
     * çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
     */
    public String shortestSuperstring(String[] words) {
        int n = words.length;
        int [][] graph = new int[n][n];
        build_graph(graph,words);

        int [][] dp = new int[1<<n][n]; // ç¬¬ä¸€ä¸ªç»´åº¦è¡¨ç¤ºçŠ¶æ€ï¼Œç¬¬äºŒä¸ªç»´åº¦è¡¨ç¤ºå…ƒç´ ä¸‹æ ‡
        int [][] path = new int[1<<n][n]; // è¡¨ç¤ºå½“å‰çš„çˆ¶èŠ‚ç‚¹
        for (int i = 0; i < path.length; i++) Arrays.fill(path[i],-1);
        int min = Integer.MAX_VALUE;
        int last = -1;

        for (int curState = 1; curState < (1<<n); curState++) {
            Arrays.fill(dp[curState],Integer.MAX_VALUE / 2);

            for (int curNode = 0; curNode < n; curNode++) {
                if ((curState&(1 << curNode)) == 0) continue; // æ˜¯å¦è®¿é—®è¿‡
                int prevState = curState ^ (1 << curNode);
                if (prevState == 0) {
                    dp[curState][curNode] = words[curNode].length();
                } else {
                    for (int prevNode = 0; prevNode < n; prevNode++) {
                        if(dp[prevState][prevNode] + graph[prevNode][curNode] < 
                                dp[curState][curNode]) {
                            dp[curState][curNode] = dp[prevState][prevNode] + graph[prevNode][curNode];
                            path[curState][curNode] = prevNode;
                        }
                    }
                }

                if ((curState == (1<<n)-1) && dp[curState][curNode] < min) {
                    min = dp[curState][curNode];
                    last = curNode;
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        int s = (1 << n) - 1;

        while (s > 0) {
            int prevNode = path[s][last];
            if (prevNode == -1) {
                sb.insert(0,words[last]);
            } else {
                sb.insert(0,words[last].substring(words[last].length()-graph[prevNode][last]));
            }

            s = s ^ (1 << last);
            last = prevNode;
        } 
        return sb.toString();
    }

    public void build_graph(int [][] graph, String [] words) {
        for (int i = 0; i < words.length; i++) {
            for (int j = 0; j < words.length; j++) {
                boolean find = false;
                for (int index = 0; index < words[i].length(); index++) {
                    if((words[j]).startsWith(words[i].substring(index))) {
                        graph[i][j] = words[j].length() - (words[i].length() - index);
                        find = true;
                        break;
                    }
                }
                if (!find) {
                    graph[i][j] = words[j].length();
                }
            }
        }
    }
}
```



#### 847. è®¿é—®æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ ğŸ‰

>   ![image-20210806093653775](images/image-20210806093653775.png)
>
>   BFS + çŠ¶æ€å‹ç¼©

```python
class Solution:
    def shortestPathLength(self, graph: List[List[int]]) -> int:
        n = len(graph)
        explored = set()
        # åˆå§‹æ‰€æœ‰çŠ¶æ€
        frontier = collections.deque([(i, 1 << i) for i in range(n)])
        # ç›®æ ‡çŠ¶æ€
        goal = (1 << n) - 1
        step = 0

        while frontier:
            size = len(frontier)
            for idx in range(size):
                cur,state = frontier.popleft()
                if state == goal:
                    return step
                
                explored.add((cur,state))
                for other in graph[cur]:
                    successor = (other, 1 << other | state)
                    if successor not in explored:
                        explored.add(successor)
                        frontier.append(successor)
            step += 1    

        return -1
```







#### 765 æƒ…ä¾£ç‰µæ‰‹ ğŸ‰

>   ![image-20210806105911901](images/image-20210806105911901.png)

```python
class Solution:
    def minSwapsCouples(self,row):
        # 1. æ„å»ºå›¾
        N=len(row)//2
        graph=collections.defaultdict(list) #é‚»æ¥çŸ©é˜µ
        for i in range(0, len(row), 2):
            # ç›¸é‚»çš„ä¸¤ä¸ªäººå„è‡ªæ‰€å±çš„cpç»„
            cp_l, cp_r=row[i]//2, row[i+1]//2
            # å°†cpç»„å·ä½œä¸ºå›¾ä¸­çš„ç‚¹ æ¯ç›¸é‚»çš„ä¸¤ä¸ªéƒ½å»ºç«‹è¾¹ (æ— éœ€è®¨è®ºæ˜¯å¦ä¸ºcp å› ä¸ºå¦‚æœä¸ºcpåˆ™æ˜¯åŒä¸€ä¸ªç‚¹)
            graph[cp_l].append(cp_r)
            graph[cp_r].append(cp_l)
            
        # 2. ä¸‹é¢ç”¨å¹¿åº¦ä¼˜å…ˆéå†æ¥æ•°è”é€šåˆ†é‡çš„æ•°ç›®
        visited=[False for _ in range(N)]
        num_group=0
        for i in range(N):
            if not visited[i]:
                visited[i]=True
                queue=collections.deque([i])
                while queue:
                    cur = queue.popleft()
                    for successor in graph[cur]:
                        if not visited[successor]: 
                            # å¦‚æœå±äºåŒä¸€è”é€šåˆ†é‡ åˆ™åŠ å…¥å½“å‰è”é€šåˆ†é‡çš„é˜Ÿåˆ—
                            queue.append(successor)                     
                            visited[successor]=True # ä¸”æ ‡è®°éå†è¿‡
                num_group += 1 #è”é€šåˆ†é‡æ•°ç›®+1
	    
        # 3. Nä¸ªæƒ…ä¾£ï¼Œæœ‰kä¸ªè¿é€šåˆ†é‡ï¼Œåˆ™éœ€è¦äº¤æ¢N-kæ¬¡
        return N-num_group
```

#### 547. çœä»½æ•°é‡

>   ![image-20210806110946834](images/image-20210806110946834.png)
>
>   **æ±‚è¿é€šå›¾çš„æ•°é‡**

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        ans = 0
        visited = [False]*n

        for i in range(n):
            if not visited[i]:
                visited[i] = True
                queue = collections.deque([i])

                while queue:
                    size = len(queue)
                    for i in range(size):
                        cur = queue.popleft()
                        for i in range(n):
                            if isConnected[cur][i] == 1 and not visited[i]:
                                visited[i] = True
                                queue.append(i)
                ans += 1
        return ans

```





#### 329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„ ğŸ‰

>   ![image-20210806125746664](images/image-20210806125746664.png)
>
>   æ€è·¯ï¼šå›¾æœç´¢é—®é¢˜ã€‚
>
>   è¿™ä¸€é¢˜ååˆ†å®¹æ˜“å¼„é”™ï¼Œå…³é”®åœ¨äºæ²¡æœ‰å˜æ¸…é€’å½’å‡½æ•°çš„ä½œç”¨ï¼Œé€’å½’å‡½æ•°çš„ä½œç”¨åœ¨äºæ‰¾åˆ°ä»¥`(i,j)`ä¸ºå¼€å§‹çš„æœ€é•¿é€’å¢åºåˆ—çš„é•¿åº¦ï¼Œæ‰€ä»¥å®ƒåº”è¯¥è¿”å›å¯¹åº”çš„é•¿åº¦ï¼Œè€Œä¸åº”è¯¥åªæ˜¯é€’å½’ã€‚å…¶æ¬¡ï¼Œvisistedæ•°ç»„æœ‰æ²¡æœ‰å¿…è¦å­˜åœ¨ï¼Œæ²¡æœ‰å¿…è¦ï¼Œå› ä¸ºèƒ½å¤Ÿé€’å½’ä¸‹å»ä¸€å®šè¡¨ç¤ºä¸‹ä¸€ä¸ªå…ƒç´ å¤§äºå½“å‰å…ƒç´ ï¼Œé‚£å°±ä¸ä¼šå‡ºç°é‡å¤è®¿é—®çš„é—®é¢˜ï¼Œå½“è®©ç”¨visitedæ•°ç»„ä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯éœ€è¦åˆ©ç”¨å›æº¯çš„è§„åˆ™ï¼Œè¿›è¡Œå›æº¯æ“ä½œã€‚

```python
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        directions = [[0,1],[0,-1],[1,0],[-1,0]]
        m = len(matrix)
        n = len(matrix[0])

        def helper(i,j):
            if dp[i][j] > 0: return dp[i][j]

            for dirs in directions:
                x = i + dirs[0]
                y = j + dirs[1]
                if x >= 0 and x < m and y >= 0 and y < n:
                    if matrix[i][j] < matrix[x][y]:
                        if dp[x][y] > 0:
                            dp[i][j] = max(dp[i][j],dp[x][y])
                        else:
                            dp[i][j] = max(dp[i][j],helper(x,y))
            dp[i][j] += 1
            return dp[i][j]

        dp = [[0]*n for i in range(m)] # å…¨å±€çš„
        ans = 0
        for i in range(m):
            for j in range(n):
                if dp[i][j] > 0: continue
                ans = max(ans,helper(i,j))
        return ans
```

## ç¯ç›¸å…³

#### 685. å†—ä½™è¿æ¥ II ğŸ‰

[ã€ç»†è‡´è§£è¯»ã€‘ä¸€æ–‡è®©ä½ çœŸæ­£è¯»æ‡‚æœ¬é¢˜çš„æ€è·¯](https://leetcode-cn.com/problems/redundant-connection-ii/solution/xi-zhi-jie-du-yi-wen-rang-ni-zhen-zheng-du-dong-be/)

å¦‚æœå°†æ ‘çœ‹æˆå›¾ï¼Œé‚£ä¹ˆåªæœ‰æ ¹èŠ‚ç‚¹ `å…¥åº¦ä¸º0ï¼Œå‡ºåº¦ä¸º2`ï¼Œè€Œå…¶ä½™èŠ‚ç‚¹`å…¥åº¦ä¸º1ï¼Œå‡ºåº¦ä¸º1`ï¼›å½“å‘ä¸€æ£µæœ‰å‘æ ‘æ’å…¥ä¸€æ¡é¢å¤–çš„è¾¹ $u \rightarrow v$ æ—¶ï¼Œæœ‰ä¸¤ç§å¯èƒ½ï¼š

+   æ‰€æœ‰èŠ‚ç‚¹å…¥åº¦å’Œå‡ºåº¦éƒ½ä¸º1ã€‚ï¼ˆåˆ©ç”¨å¹¶æŸ¥é›†è§£å†³ï¼‰
+   æœ‰ä¸€ä¸ªèŠ‚ç‚¹å…¥åº¦ä¸º2ã€‚

è€Œ`å…¥åº¦ä¸º2çš„èŠ‚ç‚¹`çš„ä¸¤æ¡è¾¹ä¸­çš„ä¸€æ¡è¾¹å°±æ˜¯æˆ‘ä»¬è¦åˆ é™¤çš„ï¼Œè€Œä¸¤æ¡è¾¹çš„æƒ…å†µå¦‚ä¸‹ï¼š

+   ä¸€æ¡è¾¹åœ¨ç¯å¤–ï¼Œä¸€æ¡è¾¹åœ¨ç¯å†…ï¼šéœ€è¦å»æ‰åœ¨ç¯å†…çš„é‚£æ¡è¾¹ã€‚
+   ä¸¤æ¡è¾¹éƒ½åœ¨ç¯å†…ï¼šå»é™¤å…¶ä¸­ä¸€æ¡å³å¯ã€‚æ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬è¦å»é™¤åå‡ºç°çš„é‚£æ¡ã€‚

```python
class UF:
    def __init__(self,nums):
        self.parent = {num:num for num in nums}
    
    def find(self,x):
        while self.parent[x] != x:
            x = self.parent[x]
        return x
    
    def union(self,x,y):
        x_root = self.find(x)
        y_root = self.find(y)
        if x_root != y_root:
            if x_root > y_root:
                self.parent[y_root] = x_root
            else:
                self.parent[x_root] = y_root
        else:
            return [x,y]

class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        # é™¤äº†æ ¹èŠ‚ç‚¹ä¹‹å¤–ï¼Œæ¯ä¸€ä¸ªèŠ‚ç‚¹æœ‰ä¸”åªæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹
        n = len(edges)
        indegree = [0]*(n+1)
        outdegree = [0]*(n+1)
        graph = collections.defaultdict(list)
        for edge in edges:
            indegree[edge[1]] += 1
            outdegree[edge[0]] += 1
            graph[edge[1]].append(edge[0])
        
        flag2degree = False
        v = -1
        for i in range(1,n+1):
            if indegree[i] == 2: 
                flag2degree = True
                v = i # å…¥åº¦ä¸º 2 çš„èŠ‚ç‚¹
                break
        
        """ ä¸å­˜åœ¨å…¥åº¦ä¸º2çš„èŠ‚ç‚¹ """
        if not flag2degree:
            uf = UF([i+1 for i in range(n)])
            for edge in edges:
                res = uf.union(edge[0], edge[1])
                if res is not None:
                    return edge
        else:
            """ å­˜åœ¨å…¥åº¦ä¸º2çš„èŠ‚ç‚¹ """
            points2v = graph[v][::-1]
            for p in points2v:
                if indegree[p] != 0 or outdegree[p] != 0:
                    cur = p
                    while cur in graph:
                        if cur == v:
                            """ å­˜åœ¨ç¯ï¼Œè¿”å›ç¯å†…çš„è¾¹ """
                            return [p,v]
                        else:
                            cur = graph[cur][0]
            """ ä¸å­˜åœ¨ç¯ï¼Œä»»æ„æ‹†é™¤ä¸€æ¡è¾¹å³å¯ """
            for p in points2v:
                if indegree[p] != 0 or outdegree[p] != 0:
                    return [p,v]
```


â€‹    







## å¹¶æŸ¥é›†

#### åŸºæœ¬æ¡†æ¶

```python
import collections
from typing import *

class UnionFind:
    def __init__(self,nums):
        self.parent = {num:num for num in nums}
        self.count = collections.defaultdict(lambda: 1)
    
    def find(self,x):
        while x != self.parent[x]:
            x = self.parent[x]
        return x
    
    def union(self,x,y):
        x_root = self.find(x)
        y_root = self.find(y)

        if x_root == y_root: return
        self.parent[y_root] = x_root
```



#### 684. å†—ä½™è¿æ¥

>   ![image-20210806151159543](images/image-20210806151159543.png)
>
>   è¿™ä¸€é¢˜å®é™…ä¸Šå’Œæœ€å°ç”Ÿæˆæ ‘æ€è·¯å¾ˆç±»ä¼¼ï¼Œéƒ½æ˜¯åˆ©ç”¨**å¹¶æŸ¥é›†**çš„æ€æƒ³å¯¹å›¾ä¸­çš„å…ƒç´ ä¸€ä¸€åˆå¹¶

```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        father = {i+1:i+1 for i in range(n)}


        for edge in edges:
            u,v = edge
            if father[u] != father[v]:
                tmp = father[v]
                for i in range(n):
                    if father[i+1] == tmp:
                        father[i+1] = father[u]
            else:
                return edge
            
            
# å¹¶æŸ¥é›†
class UnionFind:
    def __init__(self,n):
        self.parent = {i+1:-1 for i in range(n)}
        self.rank = {i+1:1 for i in range(n)}

    def find_parent(self,index):
        while self.parent[index] != -1:
            index = self.parent[index]
        return index
    
    def union(self,x,y):
        x_parent = self.find_parent(x)
        y_parent = self.find_parent(y)

        if x_parent != y_parent:
            # è¿›è¡Œåˆå¹¶
            if self.rank[x_parent] >= self.rank[y_parent]:
                self.rank[y_parent] += 1
                self.parent[x_parent] = y_parent
            else:
                self.rank[x_parent] += 1
                self.parent[y_parent] = x_parent
            return True
        else:
            # æ‹’ç»åˆå¹¶
            return [x,y]


class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        uf = UnionFind(n)

        for edge in edges:
            res = uf.union(edge[0],edge[1])
            if res != True:
                return res
```





#### meituan-002. å°ç¾çš„ä»“åº“æ•´ç† ğŸ‰

>   ![image-20210823150700198](images/image-20210823150700198.png)

```python
import sys

def solution(n,weight,query):
    # ç»´æŠ¤åŒºé—´å’Œ
    s = [0 for i in range(n)]
    # åˆ†åˆ«è¡¨ç¤ºå½“å‰ç‚¹çš„`å·¦è¾¹ç•Œ`å’Œ`å³è¾¹ç•Œ`
    right_bound = [i for i in range(n)]
    left_bound = [i for i in range(n)]

    ans = []
    cur = 0
    for i in query[::-1]:
        i = i - 1
        ans.append(cur)
        
        """ ç¬¬ä¸€æ­¥ï¼Œè®¡ç®—å¾—åˆ°åŒºé—´å’Œ """
        s[i] = weight[i] + (s[i-1] if i > 0 else 0) + (s[i+1] if i < n-1 else 0)

        """ ç¬¬äºŒæ­¥ï¼Œç»´æŠ¤åŒºé—´å·¦å³è¾¹ç•Œ """
        # ç»´æŠ¤å½“å‰åŒºé—´å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œ
        l, r = i, i
        # å³è¾¹å¤§äº0ï¼Œè¯´æ˜å³è¾¹å¯ä»¥è”åˆåœ¨ä¸€èµ·
        if i < n-1 and s[i + 1] > 0: r = right_bound[i + 1]
        # å·¦è¾¹å¤§äº0ï¼Œè¯´æ˜å·¦è¾¹å¯ä»¥è”åˆåœ¨ä¸€èµ·
        if i > 0 and s[i - 1] > 0: l = left_bound[i - 1]
        right_bound[l] = r # ç»´æŠ¤æœ€å·¦è¾¹çš„æœ€å³è¾¹è¾¹ç•Œ
        left_bound[r] = l # ç»´æŠ¤æœ€å³è¾¹çš„æœ€å·¦è¾¹è¾¹ç•Œ
        s[r] = s[l] = s[i]

        """ ç¬¬ä¸‰æ­¥ï¼Œç»´æŠ¤æœ€å¤§åŒºé—´ç´¯åŠ å’Œ"""
        cur = max(cur, s[i])
    return ans[::-1]

if __name__ == "__main__":
    try:
        n = int(sys.stdin.readline().strip())
        weight = [int(word) for word in sys.stdin.readline().strip().split()]
        query = [int(word) for word in sys.stdin.readline().strip().split()]
        ans = solution(n,weight,query)
        for val in ans:
            print(val)
    except:
        pass
```



#### [128 æœ€é•¿è¿ç»­åºåˆ— ](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/tu-jie-yu-dao-jiu-shen-jiu-bing-cha-ji-by-chun-men/)

>   ![image-20210901155229364](images/image-20210901155229364.png)

```python
class UF:
    def __init__(self,nums):
        self.parent = {num:num for num in nums}
    
    def find(self,x):
        while self.parent[x] != x:
            x = self.parent[x]
        return x
    
    def union(self,x,y):
        x_root = self.find(x)
        y_root = self.find(y)
        if x_root != y_root:
            if x_root < y_root:
                self.parent[y_root] = x_root
            else:
                self.parent[x_root] = y_root
        
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        uf = UF(nums)
        for num in nums:
            if num+1 in uf.parent:
                uf.union(num,num+1)
        counter = collections.defaultdict(int)
        for k,v in uf.parent.items():
            counter[uf.find(v)] += 1
        
        ans = 0
        for k,v in counter.items():
            ans = max(ans,v)
        return ans
```



## å›¾æœç´¢é—®é¢˜



#### 785. åˆ¤æ–­äºŒåˆ†å›¾ ğŸ‰ğŸ‰ğŸ‰

>   ![image-20210831172828748](images/image-20210831172828748.png)ä¸¤ç§æ€è·¯ï¼š
>
>   +   ç¬¬ä¸€ç§ï¼Œå‡è®¾åªæœ‰ä¸¤ç§é¢œæ–™ï¼Œ1å’Œ2ï¼Œå…ˆæ¶‚é¢œæ–™1ï¼Œç„¶åæ¶‚é¢œæ–™2ï¼Œå¦‚æœåœ¨æ¶‚çš„è¿‡ç¨‹ä¸­å‡ºç°å†²çªï¼Œåˆ™ä¸å¯èƒ½äºŒåˆ†ã€‚
>   +   ç¬¬äºŒç§ï¼Œæœ‰å¾ˆå¤šç§é¢œæ–™ï¼Œç›¸é‚»èŠ‚ç‚¹ä¸å¯æ¶‚åŒæ ·çš„é¢œæ–™ï¼Œå…¨éƒ¨æ¶‚å®Œä¹‹åï¼Œæ£€æŸ¥é¢œæ–™ç§ç±»çš„æ•°é‡ã€‚

+   ç¬¬ä¸€ç§

    ```python
    class Solution:
        def isBipartite(self, graph: List[List[int]]) -> bool:
            n = len(graph)
            if n <= 1: return True
    
            paint = [0]*n
            queue = collections.deque()
    
            for i in range(n):
                if paint[i] == 0:
                    paint[i] = 1
                    queue.append(i)
    
                while queue:
                    cur = queue.popleft()
                    for v in graph[cur]:
                        if paint[v] == 0:
                            paint[v] = 1 if paint[cur] == 2 else 2
                            queue.append(v)
                        else:
                            if paint[cur] == paint[v]: return False
            return True
    ```

+   ç¬¬äºŒç§

```python
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        if n <= 1: return True

        paint = [0]*n
        queue = collections.deque()

        for i in range(n):

            if paint[i] == 0:
                queue.append(i)
                while queue:
                    cur = queue.popleft()

                    # æ‰¾åˆ°å¯ä»¥æŸ“è‰²çš„é¢œè‰²
                    color_set = set()
                    for v in graph[cur]:
                        if paint[v] != 0:
                            color_set.add(paint[v])
                    color_list = list(color_set)
                    color_list.sort()
                    color = 1
                    for c in color_list:
                        if color == c:
                            color += 1
                        else: break
                    paint[cur] = color

                    # è®²æœªæŸ“è‰²çš„èŠ‚ç‚¹åŠ å…¥
                    for v in graph[cur]:
                        if paint[v] == 0:
                            queue.append(v)
        
        return len(set(paint)) == 2
```



#### 133. å…‹éš†å›¾ ğŸ‰

>   ![image-20210910112859262](images/image-20210910112859262.png)
>
>   ![img](images/1630217173-tSmRvn-file_1630217174057)

````python
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node: return node
        queue = collections.deque()
        node_dict = {node.val:Node(node.val)}
        queue.append(node)

        while queue:
            size = len(queue)
            for i in range(size):
                cur = queue.popleft()
                # copy nodes
                for neighbor in cur.neighbors:
                    if neighbor.val not in node_dict:
                        node_dict[neighbor.val] = Node(neighbor.val)
                        queue.append(neighbor)
                    node_dict[cur.val].neighbors.append(node_dict[neighbor.val])
        return node_dict[node.val]
````





#### 332. é‡æ–°å®‰æ’è¡Œç¨‹









#### 399. é™¤æ³•æ±‚å€¼





#### 947. ç§»é™¤æœ€å¤šçš„åŒè¡Œæˆ–åŒåˆ—çŸ³å¤´





## æ‹“æ‰‘æ’åº

#### 207 è¯¾ç¨‹è¡¨

>   ![image-20210806094241906](images/image-20210806094241906.png)
>
>   æ‹“æ‰‘æ’åº

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # æ„å»ºå›¾å’Œå…¥åº¦è¡¨
        graph = [[] for i in range(numCourses)]
        in_degree = [0]*numCourses
        for prerequisite in prerequisites:
            graph[prerequisite[1]].append(prerequisite[0])
            in_degree[prerequisite[0]] += 1
        
        queue = collections.deque()
        visited = [False]*numCourses
        for i in range(numCourses):
            if in_degree[i] == 0:
                queue.append(i)
                visited[i] = True
        
        while queue:
            size = len(queue)
            for i in range(size):
                cur = queue.popleft()
                for next_p in graph[cur]:
                    in_degree[next_p] -= 1

            for i in range(numCourses):
                if not visited[i] and in_degree[i] == 0:
                    visited[i] = True
                    queue.append(i)
        for i in range(numCourses):
            if not visited[i]: return False
        return True
```



#### [210. è¯¾ç¨‹è¡¨ II](https://leetcode-cn.com/problems/course-schedule-ii/)

>   ![image-20210901155619517](images/image-20210901155619517.png)

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        inorder = [0 for i in range(numCourses)]
        graph = {i:[] for i in range(numCourses)}
        ans = []

        for edge in prerequisites:
            inorder[edge[0]] += 1
            graph[edge[1]].append(edge[0])
	    
        # é¦–å…ˆå°†æ‰€æœ‰å…¥åº¦ä¸º0çš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
        queue = []
        for i in range(numCourses):
            if inorder[i] == 0:
                queue.append(i)
	    
        # éå†é˜Ÿåˆ—ï¼ŒåŒæ—¶æ›´æ–°å…¥åº¦åˆ—è¡¨
        while queue:
            top = queue.pop(0)
            ans.append(top)
            for next_ in graph[top]:
                inorder[next_] -= 1
                # æ›´æ–°çš„è¿‡ç¨‹ä¸­å‡ºç°å…¥åº¦ä¸º0çš„èŠ‚ç‚¹ï¼Œå…¥é˜Ÿ
                if inorder[next_] == 0:
                    queue.append(next_)
                    
        # æ‰€æœ‰èŠ‚ç‚¹å…¥åº¦éƒ½ä¸ä¸º0
        for i in range(numCourses):
            if inorder[i] != 0:
                return []

        return ans
```

## å•&åŒå‘BFS

#### 815. å…¬äº¤è·¯çº¿ ğŸ‰ğŸ‰

>   ![image-20210906102402968](images/image-20210906102402968.png)

```python
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        if source == 0 and target == 100000:
            return -1
        # æ„å»ºå›¾ {ç‚¹ï¼šè·¯çº¿ï¼Œç‚¹ï¼šè·¯çº¿}
        graph = collections.defaultdict(list)
        for route in routes:
            for v in route:
                graph[v].extend(route)
        if source not in graph or target not in graph:
            return -1
        queue = collections.deque([source])
        visited = {source}
        step = 0
        while queue:
            size = len(queue)
            step += 1
            for i in range(size):
                cur = queue.popleft()
                if cur == target:
                    return step-1
                for v in graph[cur]:
                    if v not in visited:
                        visited.add(v)
                        queue.append(v)
        return -1
```



#### 126. å•è¯æ¥é¾™ II ğŸ‰ğŸ‰

>   ![image-20210906104359353](images/image-20210906104359353.png)
