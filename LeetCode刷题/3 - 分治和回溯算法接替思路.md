## å›æº¯ç®—æ³•

![å›æº¯pdfå¤§çº²](../\LeetCodeåˆ·é¢˜\images\1614612372-lvfwtC-file_1614612372485)


$$
å›æº¯ç®—æ³•æœ¬è´¨ä¸Šæ˜¯æ¨ªå‘çš„æœç´¢å’Œçºµå‘çš„æœç´¢ï¼Œæ¨ªå‘æœç´¢æ˜¯å¯¹æ‰€æœ‰å¶å­èŠ‚ç‚¹çš„éå†ï¼Œçºµå‘æœç´¢æ˜¯å¯¹æ‰€æœ‰æ ‘æ·±çš„é€’å½’ã€‚
$$

#### 1.1 æ¦‚è¿°

>   å¸¸è§çš„æ¡ä»¶

æ˜¯å¦æœ‰é‡å¤æ•°å­—ï¼Œæ¯”å¦‚`[1,1,2,2,3]`è¿™æ ·çš„æ•°æ®ã€‚

æ•°å­—æ˜¯å¦å¯é‡å¤ä½¿ç”¨ï¼Œæ¯”å¦‚`[1,2,3]`ï¼Œä½†æ˜¯`1`å¯ä»¥é‡å¤ä½¿ç”¨ã€‚

é¡ºåºæ˜¯å¦é‡è¦ï¼Œæ¯”å¦‚`[1,2]`æ˜¯å¦å’Œ`[2,1]`ç›¸åŒã€‚

>   å¸¸è§çš„é—®é¢˜

+   **ç»ˆæ­¢æ¡ä»¶**ä¸æ˜ç¡®ï¼Œå¯¼è‡´é€’å½’æ— é™å»¶ä¼¸
+   **ä¸‹æ ‡ä¸æ˜ç¡®**ï¼Œå¯¼è‡´æ•°å­—å…³ç³»é”™ä½

>   å¸¸è§çš„ç±»å‹

+   ä¸€ç±»æ˜¯å•æ¡ä»¶çš„å›æº¯ï¼Œæ¯”å¦‚é•¿åº¦ç»„åˆè¿™ç±»é—®é¢˜
+   ä¸€ç±»æ˜¯å¤šæ¡ä»¶çš„å›æº¯ï¼Œæ¯”å¦‚é•¿åº¦å’Œç›®æ ‡å’Œï¼Œä»¥åŠä¸€äº›å˜ç§ï¼Œå¤šæ¡ä»¶çš„å›æº¯ï¼Œä¸€å®šè¦æ³¨æ„åªæ»¡è¶³å•æ¡ä»¶æƒ…å†µä¸‹çš„å¤„ç†ã€‚

>   åŸºæœ¬æ¡†æ¶

ä¸€ä¸ªå›æº¯é—®é¢˜å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå†³ç­–æ ‘çš„éå†è¿‡ç¨‹ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘ä¸‰ä¸ªå› ç´ ï¼š

+ è·¯å¾„
+ é€‰æ‹©åˆ—è¡¨ **å¦‚ä½•æ§åˆ¶é€‰æ‹©åˆ—è¡¨å¾ˆé‡è¦**
+ ç»“æŸæ¡ä»¶

åŸºæœ¬çš„æ¨¡æ¿å¦‚ä¸‹ï¼š

```python
result = []
def backtrace(è·¯å¾„,é€‰æ‹©åˆ—è¡¨):
    if æ»¡è¶³ç»“æŸæ¡ä»¶:
        result.add(è·¯å¾„)
        return
    
    for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
        åšé€‰æ‹©
        backtrace(è·¯å¾„,é€‰æ‹©åˆ—è¡¨)
        æ’¤é”€é€‰æ‹©
```

#### 1.2 é¢˜ç›®

##### 77 ç»„åˆ

>   ![image-20210901204053764](images/image-20210901204053764.png)
>
>   æ€è·¯ï¼šæ— é¡ºåºï¼Œæ•°å­—ä¸å¯é‡å¤ä½¿ç”¨ï¼Œæ— é‡å¤æ•°å­—ï¼Œè¿™æ ·è§£ç©ºé—´æ ‘å¯ä»¥ã€‚

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        self.ans = []
        def helper(start,path):
            if len(path) == k:
                self.ans.append(path[:])
                return
            
            for i in range(start,n+1):
                helper(i+1,path+[i])
        
        helper(1,[])
```

##### 39. ç»„åˆæ€»å’Œ

>   ![image-20210901204124679](images/image-20210901204124679.png)
>
>   æ€è·¯ï¼šä¸å­˜åœ¨é‡å¤æ•°å­—ï¼Œå¯ä»¥é‡å¤ä½¿ç”¨ï¼Œæ— é¡ºåº

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        """
        æ— é‡å¤ï¼Œæ•°å­—å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œä¸è€ƒè™‘é¡ºåº
        """
        N = len(candidates)
        self.ans = []
        def helper(start,path,target):
            if target == 0:
                self.ans.append(path)
                return 

            for i in range(start,N):
                if target >= candidates[i]:
                    helper(i,path+[candidates[i]],target-candidates[i])
        
        helper(0,[],target)
        return self.ans                

```

##### 40 ç»„åˆæ€»å’ŒII

>   ![image-20210901204145330](images/image-20210901204145330.png)
>
>   æ€è·¯ï¼šå­˜åœ¨é‡å¤æ•°å­—ï¼›æ•°å­—ä¸å¯é‡å¤ä½¿ç”¨ï¼Œæ— é¡ºåºã€‚

```python
def helper(start,path,target):
    if target == 0:
        ans.append(path[:])
        return 
   	for i in range(start,len(candinates)):
        if i > start and candinates[i] == candinates[i-1]: # candinates[i] == candinates[i-1]æ˜¯ä¸ºäº†å‰”é™¤é‡å¤ç»“æœ
            continue
        
        if target-candinates[i] >= 0:
            helper(i+1,path+[candinates[i]],target-candinates[i]) # i+1æ˜¯é¿å…å¯¹é‡å¤å…ƒç´ çš„ä½¿ç”¨
```

##### 216 ç»„åˆæ€»å’ŒIII

>   ![image-20210901204208048](images/image-20210901204208048.png)
>
>   æ€è·¯ï¼šéœ€è¦æ³¨æ„ï¼Œé¢˜ç›®éœ€è¦åŒæ—¶æ»¡è¶³é•¿åº¦ä¸ºkï¼Œå¹¶ä¸”å’Œä¸ºnï¼Œå…³é”®åœ¨äºåŒæ—¶ï¼Œæ‰€ä»¥éœ€è¦æ³¨æ„ç»ˆæ­¢æ¡ä»¶ã€‚

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        """
        æ•°å­—ä¸é‡å¤ï¼Œæ•°å­—ä¸èƒ½é‡å¤é€‰æ‹©ï¼Œä¸è€ƒè™‘é¡ºåº
        """
        N = n
        self.ans = []

        def helper(start,path,target):
            if len(path) == k:
                if target == 0:
                    self.ans.append(path[:])
                return
            if start > 9: return

            for i in range(start,9+1):
                if target >= i:
                    helper(i+1,path+[i],target-i)
        
        helper(1,[],n)
        return self.ans
```



##### 46 å…¨æ’åˆ—

>   æ€è·¯ï¼šçœ‹é‡é¡ºåºï¼ŒåŒä¸€ä¸ªå…ƒç´ ä¸èƒ½é‡å¤ä½¿ç”¨
>
>   ![image-20210901204236583](images/image-20210901204236583.png)

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        """
        1. ä¸å«é‡å¤æ•°å­—
        2. æ•°å­—ä¸èƒ½é‡å¤ä½¿ç”¨
        3. é¡ºåºé‡è¦ï¼Œä¸åŒé¡ºåºä»£è¡¨ä¸åŒç»“æœ
        """
        self.ans = []
        def helper(path,used):
            if len(path) == len(nums):
                self.ans.append(path[:])
                return
            
            for i in range(len(nums)):
                if not used[i]:
                    used[i] = True
                    helper(path+[nums[i]],used)
                    used[i] = False
        
        path = []
        used = [False]*len(nums)
        helper(path,used)
        return self.ans
```



##### 78 å­é›†

>   æ€è·¯ï¼šæ•°å­—ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Œä¸è€ƒè™‘é¡ºåº
>
>   ![image-20210901204332152](images/image-20210901204332152.png)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        def helper(start,path):
            self.ans.append(path[:]) # ç›¸å½“äºåŠ ä¸Šç©ºæ ¼
            for i in range(start,len(nums)):
                helper(i+1,path+[nums[i]])
        
        path = []
        helper(0,path)

        return self.ans
```



##### 79 å•è¯æœç´¢

>   ![image-20210901204358990](images/image-20210901204358990.png)
>
>   æ€è·¯ï¼š**å®šä¹‰DFSä¼ å…¥å‚æ•°çš„å«ä¹‰**ï¼Œ`dfs(i,j,idx)`è¡¨ç¤ºçš„å«ä¹‰æ˜¯è®¿é—®`board[i][j]`å·²ç»ä¸`word[idx]`åŒ¹é…ï¼Œå¦‚æœ`idx==len(word)-1`ï¼Œè¿™æ—¶å€™å°±è¦è¿”å›æ‰¾åˆ°

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        """
        ç»™å®šä¸€ä¸ªäºŒç»´ç½‘æ ¼å’Œä¸€ä¸ªå•è¯ï¼Œæ‰¾å‡ºè¯¥å•è¯æ˜¯å¦å­˜åœ¨äºç½‘æ ¼ä¸­ã€‚
        å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ç›¸é‚»çš„å•å…ƒæ ¼å†…çš„å­—æ¯æ„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–å‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚
        åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚
        """
        m = len(board)
        n = len(board[0])
        visited = [[0 for j in range(n)]for i in range(m)]
        directions = [[0,1],[0,-1],[1,0],[-1,0]]
        flag = [False]
        def dfs(t,x,y):
            if flag[0]:
                return
            if t == len(word)-1:
                flag[0] = True
                return
            for direction in directions:
                new_x = x + direction[0]
                new_y = y + direction[1]
                if new_x >= 0 and new_x < m and new_y >= 0 and new_y < n:
                    if not visited[new_x][new_y] and t+1 <= len(word) - 1 and board[new_x][new_y] == word[t+1]:
                        visited[new_x][new_y] = 1
                        dfs(t+1,new_x,new_y)
                        visited[new_x][new_y] = 0

        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    visited[i][j] = 1
                    dfs(0,i,j)
                    visited[i][j] = 0
        return flag[0]
```



##### 93 å¤åŸIPåœ°å€

>   ![image-20210901204516408](images/image-20210901204516408.png)
>
>   æ€è·¯ï¼šä¸»è¦æ³¨æ„å’Œ216æœ‰ç‚¹ç›¸ä¼¼ï¼Œéœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶å›æº¯æ‰ä¼šç»ˆæ­¢ï¼Œä¸€ä¸ªæ˜¯å…ƒç´ çš„æ•°é‡ä¸º4ï¼Œå¦ä¸€ä¸ªæ˜¯æ‰€æœ‰çš„å­—ç¬¦éƒ½è¢«ç”¨ä¸Šäº†ã€‚

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        if len(s) == 0 or len(s) > 12: return []

        ans = []
        path = []

        def helper(s,start,path):
            if len(path) == 4 and start == len(s):
                ans.append(".".join(path))
                return 
            
            if len(path) >= 4 or start >= len(s): return # æ»¡è¶³å•æ¡ä»¶æƒ…å†µä¸‹çš„å¤„ç†

            if s[start] == "0":
                helper(s,start+1,path+[s[start:start+1]]) 
            else:
                for size in range(1,4):
                    if int(s[start:start+size]) > 255:
                        break
                    else:
                        helper(s,start+size,path+[s[start:start+size]])
        helper(s,0,path)
        return ans
```



#####  301. åˆ é™¤æ— æ•ˆçš„æ‹¬å· ğŸ‰ğŸ‰

>   ![image-20210901204654893](images/image-20210901204654893.png)
>
>    æ€è·¯ï¼šåŒæ¡ä»¶å›æº¯ç®—æ³•ï¼Œä¸€ä¸ªæ˜¯éå†ç©å­—ç¬¦ä¸²ï¼Œä¸€ä¸ªæ˜¯åˆ¤æ–­åˆ é™¤çš„æ•°é‡æ˜¯å¦æ»¡è¶³éœ€æ±‚ã€‚

```python
class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        """
        æŠ“ä½ä¸€ä¸ªé‡ç‚¹ï¼Œå¦‚æœæ‹¬å·æœ‰æ•ˆï¼Œå·¦æ‹¬å·çš„æ•°é‡ä¸€å®šè¦å¤§äºç­‰äºå³æ‹¬å·çš„æ•°é‡
        """
        self.ans = set()
        def helper(index,l_cnt,r_cnt,l_rmv,r_rmv,path):
            if index == len(s):
                print(l_rmv,r_rmv)
                if l_rmv == 0 and r_rmv == 0:
                    self.ans.add(path[:])
                return
            
            # é€’å½’å†…éƒ¨ï¼š1. æ˜¯å¦åˆ é™¤å½“å‰ç¬¦å·
            if s[index] == "(" and l_rmv > 0:
                # å°è¯•åˆ é™¤å·¦æ‹¬å·
                helper(index+1,l_cnt,r_cnt,l_rmv-1,r_rmv,path)
                # å›æº¯ä¸åˆ é™¤å·¦æ‹¬å·
            
            if s[index] == ")" and r_rmv > 0:
                # å°è¯•åˆ é™¤å³æ‹¬å·
                helper(index+1,l_cnt,r_cnt,l_rmv,r_rmv-1,path)
                # å›æº¯ä¸åˆ é™¤å³æ‹¬å·

            # é€’å½’å†…éƒ¨ï¼š2. æ˜¯å¦æ·»åŠ å½“å‰ç¬¦å·
            if s[index] != "(" and s[index] != ")":
                helper(index+1,l_cnt,r_cnt,l_rmv,r_rmv,path+s[index])
            elif s[index] == "(":
                helper(index+1,l_cnt+1,r_cnt,l_rmv,r_rmv,path+s[index])
            elif s[index] == ")":
                if l_cnt > r_cnt:
                    helper(index+1,l_cnt,r_cnt+1,l_rmv,r_rmv,path+s[index])

        """ç¬¬ä¸€æ­¥ï¼šè®¡ç®—éœ€è¦åˆ é™¤æ‹¬å·çš„æ•°é‡"""
        left_remove,right_remove = 0,0
        for i in range(len(s)):
            if s[i] == "(":
                left_remove += 1
            elif s[i] == ")":
                if left_remove == 0:
                    right_remove += 1
                else:
                    left_remove -= 1
        
        """ç¬¬äºŒæ­¥ï¼šå›æº¯æ±‚è§£"""
        helper(0,0,0,left_remove,right_remove,"")
        return list(self.ans)
```



##### 37 è§£æ•°ç‹¬ ğŸ‰ğŸ‰

>   ![image-20210901204757043](images/image-20210901204757043.png)
>
>   è¿™é‡Œåœ¨è¿›è¡Œéå†çš„æ—¶å€™ï¼Œé¦–å…ˆæŒ‰åˆ—æ‰«æï¼Œæ‰«æå®Œä¸€åˆ—ä¹‹åï¼›åˆ—ä¸‹æ ‡ç½®ä¸º0ï¼ŒjåŠ ä¸€ï¼Œç›´åˆ°æ‰«æå®Œæ‰€æœ‰çš„è¡Œã€‚
>
>   ä¸‹æ ‡ä¸€å®šè¦å°å¿ƒï¼ï¼ï¼

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        n = 9
        row_dict = {j:{i:False for i in range(1,n+1)} for j in range(1,n+1)}
        col_dict = {j:{i:False for i in range(1,n+1)} for j in range(1,n+1)}
        cell_dict = {j:{i:False for i in range(1,n+1)} for j in range(1,n+1)}
        
        for i in range(n):
            for j in range(n):
                if board[i][j] != ".":
                    val = int(board[i][j])
                    row_dict[i+1][val] = True
                    col_dict[j+1][val] = True
                    cell_i = i // 3
                    cell_j = j // 3
                    cell_idx = cell_i*3 + cell_j
                    cell_dict[cell_idx+1][val] = True

        self.flag = False
        def helper(board,i,j):
            if self.flag: return
            if j == n:
                i += 1
                j = 0
                if i == n:
                    self.flag = True
                    return
            
            if board[i][j] == ".":
                cell_i = i // 3
                cell_j = j // 3
                cell_idx = cell_i*3 + cell_j
                for val in range(1,n+1):
                    if not row_dict[i+1][val] and not col_dict[j+1][val] \
                            and not cell_dict[cell_idx+1][val]:
                        board[i][j] = str(val)
                        row_dict[i+1][val] = True
                        col_dict[j+1][val] = True
                        cell_dict[cell_idx+1][val] = True

                        helper(board,i,j+1)
                        if self.flag: return

                        board[i][j] = "."
                        row_dict[i+1][val] = False
                        col_dict[j+1][val] = False
                        cell_dict[cell_idx+1][val] = False
            else:
                helper(board,i,j+1)
            if self.flag: return
        helper(board,0,0)
```



## åˆ†æ²»ç®—æ³•

#### 2.1 æ¦‚è¿°

åˆ†æ²»æ³•ä¸€å®šæ˜¯å°†é—®é¢˜é€æ­¥åˆ†è§£ï¼Œç›´åˆ°ä¸€ä¸ªå¯ä»¥ç›´æ¥æ±‚è§£çš„èŒƒå›´ï¼›ç„¶åå°†åˆ†è§£åçš„ç»“æœè¿›è¡Œç»„åˆï¼Œæ¯”å¦‚å½’å¹¶æ’åºå’Œå¿«é€Ÿæ’åºã€‚

+   åˆ’åˆ†æ ‡å‡† Divide
+   ç»ˆæ­¢æ¡ä»¶ Conquer
+   ç»“åˆ Combine

<img src="images/p" alt="è¯¦è§£åˆ†æ²»æ³•ï¼ˆdivide-and-conquerï¼‰åŠå…¶å…¸å‹åº”ç”¨_LittleMagic&#39;s Blog-ç¨‹åºå‘˜å®…åŸºåœ°- ç¨‹åºå‘˜å®…åŸºåœ°" style="zoom:50%;" />

#### [273. æ•´æ•°è½¬æ¢è‹±æ–‡è¡¨ç¤º](https://leetcode-cn.com/problems/integer-to-english-words/) ğŸ‰

>   ![image-20210902105549814](images/image-20210902105549814.png)
>
>   ![image-20210902112419365](images/image-20210902112419365.png)

```python
class Solution:
    def numberToWords(self, num: int) -> str:
        digits_20 = "One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen".split(" ")
        digits_100 = "Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety".split(" ")
        digits_up = "Thousand Million Billion".split(" ")

        def helper(num,index):
            if num == 0: return []
            if num < 20:
                return [digits_20[num-1]]
            elif num < 100:
                return [digits_100[num//10-2]] +  helper(num%10,index)
            elif num < 1000:
                return [digits_20[num//100-1]] + ["Hundred"] + helper(num%100,index)
            else:
                if (num // 1000 < 1000)  or (num // 1000 % 1000 != 0):
                    # å¤„ç†ä¸¤ç±»æ•°æ®
                    # 1. å°äºä¸€ç™¾ä¸‡çš„æ•°æ®ï¼Œè¿™äº›æ•°æ®éƒ½è¡¨ç¤ºä½ `xxx Thousand`ï¼ŒThousandèŠ‚æƒå¿…ç„¶ä¿ç•™
                    #    æ¯”å¦‚ï¼š45,400 --> Forty Five Thousand Four Hundred
                    # 2. å¤§äºä¸€ç™¾ä¸‡çš„æ•°æ®ï¼Œä½†æ˜¯åœ¨ç™¾ä¸‡ä½æƒåˆ°åƒä½èŠ‚æƒä¸­ï¼Œå­˜åœ¨éé›¶æ•°å­—ï¼Œè¿™ç±»æ•°æ®è¡¨ç¤ºä¸ºï¼š`xxx Million xxx Thousand`
                    #    æ¯”å¦‚ï¼š1,001,400
                    return helper(num//1000,index+1) + [digits_up[index]] + helper(num % 1000,index)
                else:
                    # å¤„ç†ä¸€ç±»æ•°æ®
                    # 1. å¤§äºä¸€ç™¾ä¸‡çš„æ•°æ®ï¼Œå¹¶ä¸”åœ¨ç™¾ä¸‡ä½æƒåˆ°åƒä½èŠ‚æƒä¸­ï¼Œå…¨éƒ¨ä¸ºé›¶
                    #     æ¯”å¦‚1,000,400 --> One Millon Four Hundred
                    return helper(num//1000,index+1) + helper(num % 1000,index)
        if num == 0: return "Zero"
        data = helper(num,0)
        return " ".join(data)
```

#### 315. è®¡ç®—å³ä¾§å°äºå½“å‰å…ƒç´ çš„ä¸ªæ•°

>   ![image-20210902161430648](images/image-20210902161430648.png)
>
>   è¿™ä¸€é¢˜ç±»ä¼¼äºæ±‚è§£æ‰€æœ‰é€†åºå¯¹çš„ä¸ªæ•°ï¼Œå¯¹æ•°ç»„è¿›è¡Œå½’å¹¶æ’åºï¼Œåœ¨æŸä¸€æ¬¡åˆ†å‰²ä¸­ï¼Œå½’å¹¶æ’åºå·¦è¾¹æ˜¯æœ‰åºçš„ï¼Œå³è¾¹ä¹Ÿæ˜¯æœ‰åºçš„ï¼Œå¦‚æœåœ¨åˆå¹¶çš„æ—¶å€™ï¼Œå·¦è¾¹å°äºå³è¾¹çš„æŸä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆå·¦è¾¹å°äºå³è¾¹çš„æ‰€æœ‰å…ƒç´ ã€‚
>
>   ![315-merge-sort-20.png](images/1624981721-GlhaCs-315-merge-sort-20.png)

```python
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        dp = []
        n = len(nums)
        left,right = 0,n-1
        while left <= right:
            nums[left],nums[right] = nums[right],nums[left]
            left += 1
            right -= 1
        
        ans = collections.deque()
        for i in range(n):
            if not dp or dp[-1] < nums[i]:
                ans.appendleft(len(dp))
                dp.append(nums[i])
            else:
                idx = bisect.bisect_left(dp,nums[i])
                dp[idx:idx] = [nums[i]]
                ans.appendleft(idx)
        return list(ans)
```

#### [327. åŒºé—´å’Œçš„ä¸ªæ•°](https://leetcode-cn.com/problems/count-of-range-sum/) ğŸ‰

>![image-20210903110955820](images/image-20210903110955820.png)
>
>å‰ç¼€å’Œ + äºŒåˆ†æ³• + å½’å¹¶æ’åº

```python
class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        n = len(nums)
        self.ans = 0
        prefix = [0]
        for i in range(n):
            prefix.append(nums[i] + prefix[-1])
        
        def merge_sort(nums):
            if len(nums) == 1: return nums
            k = len(nums) // 2
            nums1 = nums[:k]
            nums2 = nums[k:]
            
            merge_sort(nums1)
            merge_sort(nums2)
            
            for i in range(k):
                left = nums1[i] + lower
                right = nums1[i] + upper
                idx_l = bisect.bisect_left(nums2,left)
                idx_r = bisect.bisect_right(nums2,right)
                self.ans += (idx_r - idx_l)
            
            i = j = 0
            m = 0
            while i < len(nums1) and j < len(nums2):
                if nums1[i] <= nums2[j]:
                    nums[m] = nums1[i]
                    i += 1
                    m += 1
                elif nums1[i] > nums2[j]:
                    nums[m] = nums2[j]
                    j += 1
                    m += 1
            while i < len(nums1):
                nums[m] = nums1[i]
                m,i = m+1,i+1
            while j < len(nums2):
                nums[m] = nums2[j]
                m,j = m+1,j+1
        merge_sort(prefix)
        return self.ans
```



#### [å‰‘æŒ‡ Offer 51. æ•°ç»„ä¸­çš„é€†åºå¯¹](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

>   ![image-20210902162022996](images/image-20210902162022996.png)

```python
class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        self.ans = 0
        def merger_sort(nums):
            n = len(nums)
            if n <= 1: return
            mid = n // 2
            nums1 = nums[:mid]
            nums2 = nums[mid:]
            merger_sort(nums1)
            merger_sort(nums2)
            i = j = 0
            k = 0
            while i < len(nums1) and j < len(nums2):
                if nums1[i] <= nums2[j]:
                    nums[k] = nums1[i]
                    i += 1
                else:
                    self.ans += (len(nums1)-i)
                    nums[k] = nums2[j]
                    j += 1
                k += 1
            
            while i < len(nums1):
                nums[k] = nums1[i]
                k += 1
                i += 1
            
            while j < len(nums2):
                nums[k] = nums2[j]
                k += 1
                j += 1
        merger_sort(nums)
        return self.ans
```



#### å¤§æ•°ä¹˜æ³• ï¼ˆKaratsubaç®—æ³•ï¼‰

å¯¹äºä¸¤ä¸ªæ•°ï¼š$x=5678,y=1234$ï¼›å¯ä»¥å°† $x$ åˆ’åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œä½¿å¾— $a=56,b=78$ï¼›å°† $y$ åˆ’åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œä½¿å¾— $c=12,d=34$ã€‚å¯ä»¥å¾—åˆ°ï¼Œæ­¤æ—¶ $n=4$ï¼Œ$x=10^{n/2}a+b,y=10^{n/2}c+d$ï¼Œå¯ä»¥å¾—åˆ°ï¼š
$$
x\times y = 10^{n}ac + 10^{n/2}(ad+bc) + bd
$$
å¯¹äºå½“å‰ä¾‹å­ï¼š

+   $a\times c=672$
+   $b\times d=2652$
+   $(a+b)\times (c+d)=6164$
+   $ad+bc=6164-672-2652 = 2840$
+   $x\times y = 10^4*(a\times c) + 10^2*(a\times d+b\times c) + b\times d$



#### æŸ“è‰²é—®é¢˜ - TODO

å¦‚æœæ˜¯åŸºäºå›¾æ•°æ®çš„æŸ“è‰²é—®é¢˜ï¼Œå¹¶ä¸”å›¾æ•°æ®ä¸ä¸€å®šæ˜¯å¼ºè”é€šçš„ï¼Œæ¯”å¦‚`leetcode-785`ï¼›éœ€è¦ä¸¤é‡å¾ªç¯ï¼Œä¸€é‡å¾ªç¯æ˜¯æ­»å¾ªç¯ï¼Œéœ€è¦ä¸€ä¸ª`find`å‡½æ•°ï¼Œæ¯æ¬¡éƒ½è¦å»å¯»æ‰¾æœ‰æ•ˆçš„æœªå¡«è‰²çš„å›¾å¼€å§‹èŠ‚ç‚¹ï¼Œç›´åˆ°æ‰¾ä¸åˆ°å¡«å……çš„ç»“ç‚¹ä¸ºæˆªæ­¢ï¼›ä¸€é‡å¾ªç¯æ˜¯é˜Ÿåˆ—å¾ªç¯ï¼Œåœ¨ä¸€ä¸ªè”é€šå›¾å†…éƒ¨è¿›è¡ŒæŸ“è‰²ã€‚



