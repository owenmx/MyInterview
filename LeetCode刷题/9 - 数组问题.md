## æ•°ç»„é¢˜æ³¨æ„äº‹é¡¹

#### è§£é¢˜æ€è·¯

+   æ³¨æ„`ç»™å®šçš„æ¡ä»¶`ï¼Œæ³¨æ„`è¾¹ç•Œæƒ…å†µ`ã€‚
+   å­æ®µå’Œé—®é¢˜æ³¨æ„åˆ©ç”¨`å‰ç¼€å’Œ`æ€æƒ³ã€‚
+   å•è°ƒæ ˆ
+   åŒæŒ‡é’ˆ
+   äºŒåˆ†æ³•åŠ å¿«é€Ÿåº¦



#### å‰‘æŒ‡ Offer 29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ

æ€è·¯ï¼šä¸¤ç§è§£æ³•ï¼Œè§£æ³•ä¸€ï¼šæ¨¡æ‹Ÿç¢°å£æ³•ï¼›è§£æ³•äºŒï¼šå…¬å¼æ³•ã€‚

+   æ¨¡æ‹Ÿç¢°å£æ³•

```python
class Solution {
    public int[] spiralOrder(int[][] matrix) {

        int m = matrix.length;
        if (m == 0) return new int[0];
        int n = matrix[0].length;
        if (n == 0) return new int[0];

        int l = 0, r = n, u = 0, d = m;
        int [] ans = new int[m*n];
        int idx = 0;
        while(true) {
            for(int i = l; i < r; i++) {
                ans[idx++] = matrix[u][i];
            }
            u += 1;
            if (u >= d) break;
            for(int i = u; i < d; i++) {
                ans[idx++] = matrix[i][r-1];
            }
            r -= 1;
            if (l >= r) break;
            for (int i = r-1; i >= l; i--) {
                ans[idx++] = matrix[d-1][i];
            }
            d -= 1;
            if (u >= d) break;
            for (int i = d-1; i >= u; i--) {
                ans[idx++] = matrix[i][l];
            }
            l += 1;
            if (l >= r) break;
        }
        return ans;   
    }
}
```

+   å…¬å¼æ³•

```python
# å…¬å¼æ³•
def get_pos(x,y,m,n):
	"""
    x,yæ˜¯ä¸‹æ ‡ä»1å¼€å§‹çš„åæ ‡
    """
    k = min(min(x-1,n-y),min(y-1,m-x)) # å¯»æ‰¾å±‚æ•°
    outer_eles = k*(2*m+2*n-4*k) # ç­‰å·®æ•°åˆ—æ±‚å’Œ
    inner_eles = get_inner(x-k,y-k,m-2*k,n-2*k) # 
    return outer_eles + inner_eles

def get_inner(x,y,m,n):
    if x == 1: return y
    if y == n: return x+n-1
    if x == m: return 2*n+m-y-1
    if y == 1: return 2*m+2*n-x-2
    return 0 # default case
```



#### äºŒç»´æ•°ç»„é—®é¢˜

+   å¸¸è§æ€è·¯æ˜¯å°†äºŒç»´é—®é¢˜é™ä½ä¸ºä¸€ç»´é—®é¢˜ï¼Œç„¶ååŸºäºä¸€ç»´é—®é¢˜è¿›è¡Œæ±‚è§£



## è§£é¢˜æ–¹æ³•

### å‰ç¼€å’Œ å’Œ å­æ®µå’Œ

#### ä¸€ç»´å‰ç¼€å’Œ

![image-20210422200559506](../\LeetCodeåˆ·é¢˜\images\image-20210422200559506.png)

#### äºŒç»´å‰ç¼€å’Œ

<img src="images/1614650837-SAIiWg-1.png" alt="1.png" style="zoom: 25%;" />





#### 304. äºŒç»´åŒºåŸŸå’Œæ£€ç´¢

>   ![image-20210803171637022](images/image-20210803171637022.png)
>
>   æ€è·¯ï¼šéœ€è¦åœ¨è¡Œç»´åº¦å’Œåˆ—ç»´åº¦ä¸Šé¢å¤–å¤šæ·»åŠ ä¸€åˆ—ï¼Œè¿™æ ·å¯ä»¥èŠ‚çœå¾ˆå¤š`edge-case`çš„åˆ¤æ–­ï¼Œå…¶ä½™çš„æ€è·¯å¦‚ä¸‹ï¼š
>
>   <img src="images/1614650837-SAIiWg-1.png" alt="1.png" style="zoom: 25%;" />

```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m = len(matrix)
        n = len(matrix[0])
        self.sum_matrix = [[0]*(n+1) for i in range(m+1)]

        for i in range(1,m+1):
            for j in range(1,n+1):
                self.sum_matrix[i][j] = self.sum_matrix[i-1][j] + self.sum_matrix[i][j-1] \
                                            - self.sum_matrix[i-1][j-1] + matrix[i-1][j-1]


    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        row1 += 1
        col1 += 1
        row2 += 1
        col2 += 1
        return self.sum_matrix[row2][col2] - self.sum_matrix[row2][col1-1] \
                    - self.sum_matrix[row1-1][col2] + self.sum_matrix[row1-1][col1-1]

```

#### 523. è¿ç»­çš„å­æ•°ç»„å’Œ

>   ![image-20210803183855917](images/image-20210803183855917.png)
>
>   åˆ©ç”¨**åŒä½™æ€§è´¨**ï¼š
>
>   ![image-20210803184009361](images/image-20210803184009361.png)
>
>   éœ€è¦æ³¨æ„å››ä¸ªç‚¹ï¼š
>
>   ç¬¬ä¸€ç‚¹ï¼š`counter`éœ€è¦åˆå§‹åŒ–ï¼Œè®¾ç½®`counter[0]=-1`
>
>   ç¬¬äºŒç‚¹ï¼šå­æ•°ç»„å…ƒç´ æ€»å’Œä¸ºéœ€è¦ä¸ºk çš„å€æ•°ï¼Œåˆ©ç”¨åŒä½™å®šç†
>
>   ç¬¬ä¸‰ç‚¹ï¼šå­æ•°ç»„å¤§å°è‡³å°‘ä¸º2
>
>   ç¬¬å››ç‚¹ï¼šéœ€è¦è€ƒè™‘åˆ°0çš„å½±å“ï¼Œä¹Ÿå°±æ˜¯åŒä¸€å’Œçš„ä¸‹æ ‡æ˜¯ä¸éœ€è¦å˜åŒ–

```python
class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        counter = collections.defaultdict(int)
        counter[0] = -1
        n = len(nums)

        cur = 0
        for i in range(n):
            cur = (cur + nums[i]) % k
            if cur in counter: # å­æ•°ç»„å…ƒç´ æ€»å’Œä¸º k çš„å€æ•°ã€‚
                if i-counter[cur] >= 2: # å­æ•°ç»„å¤§å° è‡³å°‘ä¸º 2
                    return True
            else:
               counter[cur] = i
        return False
```



#### 525. è¿ç»­æ•°ç»„

>   ![image-20210803105243174](images/image-20210803105243174.png)
>
>   æ€è·¯ï¼šå‰ç¼€å’Œ + å“ˆå¸Œè¡¨
>
>   ```text
>       1. åˆå§‹åŒ–cur,ä½œä¸ºå‰ç¼€å’Œéå†çš„å€¼
>       2. é‡åˆ°0å‡ä¸€,é‡åˆ°1åŠ ä¸€
>       3. åˆ©ç”¨hashè¡¨è®°å½•, key=cur, value=i
>       4. åˆå§‹åŒ–hashè¡¨, hash[0]=-1
>   ```

```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        """
        1. åˆå§‹åŒ–cur,ä½œä¸ºå‰ç¼€å’Œéå†çš„å€¼
        2. é‡åˆ°0å‡ä¸€,é‡åˆ°1åŠ ä¸€
        3. åˆ©ç”¨hashè¡¨è®°å½•, key=cur, value=i
        4. åˆå§‹åŒ–hashè¡¨, hash[0]=-1
        """
        count = collections.defaultdict(int)
        count[0] = -1
        n = len(nums)
        cur = 0
        ans = 0

        for i in range(n):
            cur += (-1 if nums[i] == 0 else 1)
            if cur in count:
                ans = max(ans,i-count[cur])
            else:
                count[cur] = i
        return ans
```



#### 560. å’Œä¸ºkçš„å­æ•°ç»„

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        count = collections.defaultdict(int)
        n = len(nums)
        count[0] = 1
        cur = 0
        ans = 0
        for i in range(n):
            cur += nums[i]
            if (cur-k) in count:
                ans += count[cur-k]
            count[cur] += 1
        return ans
```



#### 363. çŸ©å½¢åŒºåŸŸä¸è¶…è¿‡ K çš„æœ€å¤§æ•°å€¼å’Œ ğŸ‰

>   ![image-20210805103906188](images/image-20210805103906188.png)

```python
import bisect
from sortedcontainers import SortedList

class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        m,n = len(matrix),len(matrix[0])
        self.sums = [[0]*(n+1) for _ in range(m+1)]
        for i in range(1,len(matrix)+1):
            for j in range(1,len(matrix[0])+1):
                self.sums[i][j] = matrix[i-1][j-1] + self.sums[i][j-1] + self.sums[i-1][j] - self.sums[i-1][j-1]
        
        sumRange = lambda row1,col1,row2,col2: self.sums[row2+1][col2+1] - self.sums[row2+1][col1] - self.sums[row1][col2+1] + self.sums[row1][col1]
            
        
        ans = float("-inf")
        for c1 in range(n):
            for c2 in range(c1,n):
                data = SortedList([0]) # åˆ©ç”¨äºŒåˆ†æ³•ï¼Œç»´æŠ¤çš„æ˜¯ä¸€ä¸ªæœ‰åºçš„åˆ—è¡¨
                for row in range(m):
                    s = sumRange(0,c1,row,c2)
                    lb = data.bisect_left(s-k)
                    if lb != len(data):
                        ans = max(ans,s-data[lb])
                    data.add(s)
        return ans
    
# class Solution:
#     def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
#         ans = float("-inf")
#         m,n = len(matrix),len(matrix[0])

#         for i in range(m):
#             total = [0]*n # ä¸€ç»´é—®é¢˜çš„æ•°æ®
#             for j in range(i,m):
#                 for c in range(n):
#                     total[c] += matrix[j][c] # ç¬¬jè¡Œçš„æ‰€æœ‰å…ƒç´ 
                
#                 totalSet = SortedList([0]) # å…·æœ‰é‡å¤çš„å…ƒç´ çš„æœ‰åº
#                 s = 0
#                 for v in total: # åœ¨ç»´æ•°ç»„ä¸­å¯»æ‰¾ç­”æ¡ˆ
#                     s += v
#                     lb = totalSet.bisect_left(s-k) # s-kå¾—åˆ°çš„æ˜¯æµ…é†‰å’Œ
#                     if lb != len(totalSet): # æ²¡æœ‰è¶…å‡ºèŒƒå›´
#                         ans = max(ans,s-totalSet[lb]) # å­—æ®µå’Œ s-totalSet[lb]
#                         if ans == k:  return ans 
#                     totalSet.add(s)
#         return ans
# /*~~~~~~~~~~~~~~~~~~~304 äºŒç»´åŒºåŸŸå‰ç¼€å’Œ~~~~~~~~~~~~~~~~~~~~~~~*/
# /*~~~~~~~~~~~~~~~~~~~560 å’Œä¸ºkçš„å­æ•°ç»„~~~~~~~~~~~~~~~~~~~~~~~*/
```



+   è§£æ³•äºŒï¼Œ

```python
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        m = len(matrix) # è¡Œæ•°
        n = len(matrix[0]) # åˆ—æ•°
        ans = float('-inf') # å°äºç­‰äºkçš„æœ€å¤§å­æ®µå’Œ
        self.k = k

        def dp_max(arr, k):
            # ä¸€ç»´ä¸‹çš„æœ€å¤§å­æ®µå’Œ
            cur_sum = arr[0]
            cur_max = cur_sum               # cur_maxè¡¨ç¤ºæœ€å¤§å­æ®µå’Œ
            maxnum = float('-inf')          # maxnumè¡¨ç¤ºå°äºç­‰äºkçš„æœ€å¤§å­æ®µå’Œ
            size = len(arr)

            # ä¸€ç»´çš„æœ€å¤§å­æ®µå’Œ
            for i in range(1,size):
                if cur_sum > 0: cur_sum += arr[i]
                else: cur_sum = arr[i]
                cur_max = max(cur_sum,cur_max)
                    
		   # cur_maxè¡¨ç¤ºæœ€å¤§å­æ®µå’Œï¼Œå¦‚æœæœ€å¤§å­æ®µå’Œå°äºç­‰äºkï¼Œç›´æ¥è¿”å›å³å¯
            if cur_max > maxnum and cur_max <= k:
                return cur_max
			
           # è¡¨ç¤º cur_max > kï¼Œæ‰¾åˆ°å°äºç­‰äºkçš„å­æ®µå’Œ
            for i in range(size):
                cur_sum = 0
                for j in range(i, size):
                    cur_sum += arr[j]
                    if cur_sum > maxnum and cur_sum <= k:
                        maxnum = cur_sum
                        if maxnum == k: return k
            return maxnum
        
        for i in range(n): # ä»åˆ—å¼€å§‹
            arr = [0]*m
            for j in range(i,n):
                for k in range(m):
                    arr[k] += matrix[k][j]
                ans = max(ans, dp_max(arr, self.k))
                if ans == self.k: return self.k
        return ans
```



### å±±è„‰é¢˜ 

#### 845. æ•°ç»„ä¸­çš„æœ€é•¿å±±è„‰ ğŸ‰

>   ![image-20210803095546753](images/image-20210803095546753.png)

```python
class Solution:
    def longestMountain(self, arr: List[int]) -> int:
        n = len(arr)
        left = [0]*n
        right = [0]*n

        for i in range(1,n):
            if arr[i] > arr[i-1]:
                left[i] = left[i-1] + 1
        
        for i in range(n-2,-1,-1):
            if arr[i] > arr[i+1]:
                right[i] = right[i+1] + 1
        
        return max([left[i]+right[i]+1 if left[i] > 0 and right[i] > 0 else 0 for i in range(n)])
```



#### 852. å±±è„‰æ•°ç»„çš„å³°é¡¶ç´¢å¼• ğŸ‰

>   ![image-20210802180814465](images/image-20210802180814465.png)



#### 941. æœ‰æ•ˆçš„å±±è„‰æ•°ç»„ ğŸ‰

>![image-20210802200956990](images/image-20210802200956990.png)
>
><img src="images/hint_valid_mountain_array.png" alt="img" style="zoom:67%;" />
>
>è¯¥é¢˜é™¤äº†å¯ä»¥ç”¨åŒæŒ‡é’ˆï¼Œåˆ†åˆ«ä»å¼€å¤´å’Œç»“å°¾å¯»æ‰¾å³°å€¼ä¹‹å¤–ï¼Œè¿˜å¯ä»¥åˆ©ç”¨`æœ‰é™çŠ¶æ€è‡ªåŠ¨æœº`æ¥è§£å†³ã€‚



#### 1095. å±±è„‰æ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å€¼ ğŸ‰

>   ![image-20210802194239840](images/image-20210802194239840.png)



### é‡å¤å…ƒç´ é¢˜

#### 41. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°

>   ![image-20210830163920638](images/image-20210830163920638.png)

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        """ åˆ©ç”¨æ•°ç»„æœ¬èº«çš„hashæ€§è´¨ """
        n = len(nums)
        i = 0
        while i < n:
            if nums[i] <= 0 or nums[i] > n: 
                i+=1
            else:
                if nums[i] != i+1 and nums[nums[i]-1] != nums[i]:
                    nums[nums[i]-1],nums[i] = nums[i],nums[nums[i]-1]
                else:
                    i += 1
        
        ans = 1
        for i in range(n):
            if nums[i] == i+1: ans += 1
            else: break
        return ans
```



#### 287. å¯»æ‰¾é‡å¤æ•° ğŸ‰

>   ![image-20210809102816424](images/image-20210809102816424.png)

+   äº¤æ¢å†²çªæ³• `å¸¸è§„`

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        """
        äº¤æ¢å†²çªæ³•
        """
        i = 0
        n = len(nums)

        while i < n:
            if nums[i] == i + 1:
                i += 1
            else:
                idx = nums[i] - 1
                if nums[idx] == idx+1:
                    return nums[idx]
                else:
                    nums[idx],nums[i] = nums[i],nums[idx]
```

+   å¿«æ…¢æŒ‡é’ˆ + åˆ¤ç¯æ³•

![image-20210815200629271](images/image-20210815200629271-1629029191976.png)

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # æ•°ç»„ï¼Œheadå¯ä»¥è®¤ä¸ºæ˜¯0
        # æ‰€ä»¥slowç­‰äºnums[0]ï¼Œfastç­‰äºnums[slow]
        slow = nums[0]
        fast = nums[slow]
        while True:
            if slow == fast:
                fast = 0
                while slow != fast:
                    slow = nums[slow]
                    fast = nums[fast]
                return fast
            slow = nums[slow]
            fast = nums[nums[fast]]
```



#### 565. æ•°ç»„åµŒå¥— ğŸ‰

>   ![image-20210805142057735](images/image-20210805142057735.png)
>
>   è¿™ä¸€é¢˜æœ‰ä¸¤ä¸ªå…³é”®ï¼Œä¸€ä¸ªæ˜¯ï¼š
>
>   +   Aä¸­ä¸å«æœ‰é‡å¤çš„å…ƒç´ 
>   +   Aä¸­çš„å…ƒç´ å¤§å°åœ¨[0,N-1]ä¹‹é—´
>
>   è¿™ä¸¤ä¸ªæ¡ä»¶ä¿è¯äº†æ‰€æœ‰çš„å…ƒç´ å¿…ç„¶å½¢æˆç¯ï¼Œè€Œä¸”æ‰€æœ‰çš„å…ƒç´ å­˜åœ¨äºä¸€ä¸ªç¯ä¸­ã€‚

```python
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0

        for i in range(n):
            if nums[i] == -1: continue

            count = 1
            start = i
            while nums[start] != i:
                nxt = nums[start]
                nums[start] = -1

                count += 1
                start = nxt
            nums[start] = -1  # è¾¹ç•Œæ¡ä»¶

            ans = max(ans,count)
        return ans
```



#### å‰‘æŒ‡ Offer 03. æ•°ç»„ä¸­é‡å¤çš„æ•°å­—

>   ![image-20210815200940764](images/image-20210815200940764.png)

é‡å¤å…ƒç´ ç­‰ç±»ä¼¼çš„é¢˜ç›®ï¼Œç›´æ¥æ€è·¯å°±æ˜¯`å“ˆå¸Œè¡¨`ï¼Œä½†æ˜¯å“ˆå¸Œè¡¨éœ€è¦èŠ±è´¹é¢å¤–ç©ºé—´ã€‚è€Œå“ˆå¸Œè¡¨æœ¬è´¨ä¸Šå°±æ˜¯æ•°ç»„ï¼Œæ‰€ä»¥å¯ä»¥`é€šè¿‡äº¤æ¢å†²çªæ³•`è§£å†³ã€‚

```python
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        i = 0
        n = len(nums)
        while i < n:
            if nums[i] == i:
                i += 1
            else:
                idx = nums[i]
                if nums[idx] == nums[i]:
                    return nums[i]
                else:
                    nums[idx],nums[i] = nums[i],nums[idx]
```



#### å‰‘æŒ‡ Offer 21. è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢

>   ![image-20210817142550488](images/image-20210817142550488.png)

```python
class Solution:
    def exchange(self, nums: List[int]) -> List[int]:
        n = len(nums)
        j = 0
        for i in range(n):
            if nums[i]&1:
                nums[i],nums[j] = nums[j],nums[i]
                j += 1
        return nums
```



#### 442. æ•°ç»„ä¸­é‡å¤çš„æ•°æ®

>   ![image-20211013113340589](images/image-20211013113340589.png)
>
>   

### æ•°ç»„é¢˜

#### 41. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•° ğŸ‰

>   ![image-20210805110943083](images/image-20210805110943083.png)



#### 912 æ’åºæ•°ç»„ ğŸ‰

+   å †æ’åº

+   å½’å¹¶æ’åº

+   å¿«é€Ÿæ’åº



#### 485. æœ€å¤§è¿ç»­ 1 çš„ä¸ªæ•°

>   ![image-20210805114349628](images/image-20210805114349628.png)

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        left = right = 0
        n = len(nums)
        ans = 0
        while right < n:
            if nums[right] == 1: 
                right += 1
            else:
                ans = max(right-left,ans)
                right += 1
                left = right
        ans = max(right-left,ans)
        return ans
```





#### 915. åˆ†å‰²æ•°ç»„ ğŸ‰

>   ![image-20210805145448406](images/image-20210805145448406.png)

```python
class Solution:
    def partitionDisjoint(self, nums: List[int]) -> int:
        n = len(nums)
        left = 0
        right = n-1
        mark = nums[left]
        
        # ä»å³åˆ°å·¦,æ‰¾å°äºnums[0]çš„ç¬¬ä¸€ä¸ªä¸‹æ ‡
        while right > left and nums[right] >= mark:
            right -= 1

        # ä»å·¦åˆ°å³,æ‰¾åˆ°å·¦è¾¹ä¸­æœ€æ‹”å°–çš„å…ƒç´ 
        left_max = nums[left]
        while left <= right:
            left_max = max(left_max,nums[left])
            left += 1
        
        # ä»å·¦åˆ°å³,æ‰¾åˆ°å³è¾¹å°äºå·¦è¾¹æœ€æ‹”å°–å…ƒç´ çš„ä¸‹æ ‡
        while left < n:
            if nums[left] < left_max:
                right = left
            left += 1
        
        return right + 1
    
    
#### æ›´ç®€å•çš„åšæ³•
"""
1. maxå­˜çš„æ˜¯[0, i]çš„æœ€å¤§å€¼ï¼Œposæ˜¯leftæ•°ç»„çš„åˆ†ç•Œç‚¹ï¼ŒleftMaxå­˜çš„æ˜¯leftæ•°ç»„[0, pos]çš„æœ€å¤§å€¼
2. å½“A[i] < leftMaxæ—¶ï¼Œä¸ºäº†æ»¡è¶³leftæ•°ç»„çš„æ•°å¿…é¡»å°äºç­‰äºrightä¸­çš„æ•°ï¼Œå¿…é¡»å°†å½“å‰A[i]æ”¾å…¥leftæ•°ç»„ï¼ŒåŒæ—¶æ›´æ–°leftMaxå’Œposï¼Œå½“A[i] = leftMaxæ—¶æš‚æ—¶æ²¡å¿…è¦å°†A[i]æ”¾å…¥leftæ•°ç»„ï¼Œå› ä¸ºæˆ‘ä»¬æ±‚çš„æ˜¯æœ€å°çš„left
3. å¦‚æœA[i] >= leftMaxï¼Œé‚£ä¹ˆA[i]å¯ä»¥æš‚æ—¶æ”¾åœ¨rightæ•°ç»„ï¼Œè‹¥åé¢æœ‰A[j] < leftMaxæ—¶æ‰å¿…é¡»å°†A[i]æ”¾å…¥leftæ•°ç»„
"""
class Solution {
    public int partitionDisjoint(int[] A) {
        int n = A.length;
        int max = A[0];
        int leftMax = A[0];
        int pos = 0;
        for(int i = 0; i < n; i++){
            max = Math.max(max, A[i]);
            if(A[i] >= leftMax) 
                continue;
            leftMax = max;
            pos = i;
        }
        return pos+1;
    }
}
"""
ä½œè€…ï¼šantione
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/partition-array-into-disjoint-intervals/solution/yi-ci-bian-li-bu-dong-kan-wo-by-antione/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
"""
```



#### 324. æ‘†åŠ¨æ’åº II

>   ![image-20210906093341062](images/image-20210906093341062.png)
>
>   åŸºæœ¬çš„æ€è·¯å¾ˆå®¹æ˜“æƒ³åˆ°ï¼Œå°±æ˜¯å°†æ•°ç»„æ’åºåå°†æ•°ç»„ä»ä¸­é—´ä½ç½®è¿›è¡Œç­‰åˆ†ï¼Œç„¶åå°†ä¸¤ä¸ªæ•°ç»„è¿›è¡Œç©¿æ’ã€‚
>
>   ä½†æ˜¯è¿™ç§æ€è·¯ä¼šé€ æˆä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯å¯¹äº `[1,2,2,3]` è¿™ç§æ•°æ®è€Œè¨€ï¼Œå¾—åˆ°çš„ç»“æœä»ç„¶æ˜¯ `[1,2,2,3]`ï¼Œè€ŒåŸºæœ¬çš„æ€è·¯æ˜¯å¯¹æ•°ç»„è¿›è¡Œé€†åºåå†è¿›è¡Œç©¿æ’ã€‚
>
>   é™¤äº†ç”¨ `O(nlog(n))` çš„æ¯”è¾ƒæ’åºå¤–ï¼Œè¿˜å¯ä»¥ç”¨ `O(n)` çš„æ¡¶æ’åºã€‚

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        half = n // 2
        sorted_nums = sorted(nums,key=lambda x:-x)
        right_nums = sorted_nums[:half]
        left_nums = sorted_nums[half:]
        
        for i in range(0,n,2):
            nums[i] = left_nums[i//2]
        
        for i in range(1,n,2):
            nums[i] = right_nums[i//2]
```



#### 

>   ![image-20210910085849396](images/image-20210910085849396.png)

#### 932. æ¼‚äº®æ•°ç»„ ğŸ‰

#### 1416. æ¢å¤æ•°ç»„ ğŸ‰

#### 1420. ç”Ÿæˆæ•°ç»„ ğŸ‰

