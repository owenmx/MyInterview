

>   äºŒå‰æ ‘é€’å½’ä¸‰æ¡ä»¶ï¼š
>
>   1.  é€’å½’ç»“æŸæ¡ä»¶ï¼šäºŒå‰æ ‘å·²ç©º
>   2.  æœ¬çº§é€’å½’åšçš„äº‹æƒ…ï¼šå¦‚æœå½“å‰èŠ‚ç‚¹å­˜åœ¨äºå¾…åˆ é™¤åˆ—è¡¨ä¸­ï¼Œåˆ™å°†å…¶éç©ºå­æ ‘å­˜å‚¨åˆ°forestä¸­ï¼Œå¹¶ç§»é™¤è¯¥èŠ‚ç‚¹
>   3.  æœ¬çº§é€’å½’è¿”å›å€¼ï¼šç§»é™¤æ‰ç‰¹å®šèŠ‚ç‚¹åçš„äºŒå‰æ ‘



## äºŒå‰æ ‘éå†é—®é¢˜

éå†é—®é¢˜æœ‰ä¸‰ç±»è§£æ³•ï¼Œåˆ†åˆ«æ˜¯é€’å½’ã€è¾…åŠ©æ ˆ+è¿­ä»£ã€Morriséå†ï¼ˆçº¿ç´¢äºŒå‰æ ‘ï¼‰

### å‰&ä¸­&ååºéå†

#### 145 äºŒå‰æ ‘ååºéå†

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        stack = []
        ans = []
        prev = None
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            
            root = stack.pop()
            if not root.right or root.right == prev:
                ans.append(root.val)
                prev = root
                root = None
            else:
                stack.append(root)
                root = root.right
        return ans
```



#### 653. ä¸¤æ•°ä¹‹å’Œ IV - è¾“å…¥ BST

æ€è·¯ï¼šäºŒå‰æœç´¢æ ‘ä¸­åºéå†+hashé›†åˆå¿«é€ŸæŸ¥æ‰¾ã€‚

```python
class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        self.hash_set = set()
        def find(root):
            if not root: return 
            if find(root.left): return True
            if (k -  root.val) in self.hash_set: 
                return True
            self.hash_set.add(root.val)
            if find(root.right): return True
        return find(root)
```



#### 889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘ ğŸ‰

>   æ€è·¯ï¼š
>
>   å‰åºéå†ï¼šä¸­ï¼Œå·¦ï¼Œå³
>
>   ååºéå†ï¼šå·¦ï¼Œå³ï¼Œä¸­
>
>   æ‰€ä»¥å¯ä»¥åˆ©ç”¨ååºéå†`ä¸­`çš„å‰é¢ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ˜¯å‰åºéå†`å³`çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ ·å°±å¯ä»¥è¿›è¡Œåˆ†æ²»é€’å½’ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> TreeNode:
        pre_dict = {preorder[i]:i for i in range(len(preorder))}

        def helper(pre_s,pre_e,post_s,post_e):
            if pre_s > pre_e or post_s > post_e: return None
            node = TreeNode(preorder[pre_s]) # å½“å‰èŠ‚ç‚¹
            if post_e == post_s and pre_e == pre_s: return node

            pre_right_s = pre_dict[postorder[post_e-1]] # 4
            pre_right_e = pre_e # 6
            pre_left_e = pre_right_s - 1 # 3
            pre_left_s = pre_s + 1 # 1
            pre_left_len = pre_left_e - pre_left_s + 1 # 3

            post_left_s = post_s # 0
            post_left_e = post_left_s + pre_left_len - 1 # 2
            post_right_s = post_left_s + pre_left_len # 3
            post_right_e = post_e - 1 # 6
            # print(pre_left_s,pre_left_e,post_left_s,post_left_e,"--",pre_right_s,pre_right_e,post_right_s,post_right_e)

            node.left = helper(pre_left_s,pre_left_e,post_left_s,post_left_e) # å·¦å­æ ‘
            node.right = helper(pre_right_s,pre_right_e,post_right_s,post_right_e)  # å³å­æ ‘
            return node

        return helper(0,len(preorder)-1,0,len(preorder)-1)
```





#### 872. å¶å­ç›¸ä¼¼çš„æ ‘ ğŸ‰

æ€è·¯ï¼šäºŒå‰æ ‘çš„éå†ã€‚



### å±‚æ¬¡éå†

#### 102 äºŒå‰æ ‘å±‚æ¬¡éå† å’Œ 103 äºŒå‰æ ‘çš„é”¯é½¿éå†å’Œ 107 äºŒå‰æ ‘çš„å±‚æ¬¡éå† II

102 äºŒå‰æ ‘çš„å±‚æ¬¡éå†åœ¨éå†æ¯ä¸€å±‚çš„æ—¶å€™ï¼Œå¯ä»¥å®šä¹‰éå†countè®¡ç®—å¾—åˆ°å½“å‰é˜Ÿåˆ—çš„å…ƒç´ æ•°é‡ï¼Œç„¶åä¾æ¬¡popå½“å‰é˜Ÿåˆ—ä¸­çš„å…ƒç´ ã€‚

103 äºŒå‰æ ‘çš„é”¯é½¿éå†ï¼Œåœ¨éå†æ¯ä¸€å±‚æ—¶å€™ï¼Œåœ¨æ­£å¸¸è®¿é—®çš„åŒæ—¶ï¼Œåˆ©ç”¨ä¸€ä¸ªä¸´æ—¶å˜é‡æ¥ç¡®å®šæ˜¯ä»å·¦åˆ°å³ï¼Œè¿˜æ˜¯ä»å³åˆ°å·¦



#### 199. äºŒå‰æ ‘çš„å³è§†å›¾ ğŸ‰

æ€è·¯ï¼šBFSæŒ‰å±‚éå†ï¼Œæˆ–è€…DFSå¼•å…¥depthå˜é‡ï¼Œæ¯æ¬¡è®¿é—®`depth==len(self.ans)`çš„å…ƒç´ ã€‚



#### 513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼ ğŸ‰

æ€è·¯ï¼šå’Œ199é¢˜ç±»ä¼¼ã€‚                    



#### 993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹ ğŸ‰

>   æ€è·¯ï¼šè½¬åŒ–ä¸ºæ±‚è§£æ·±åº¦å’Œçˆ¶èŠ‚ç‚¹çš„é—®é¢˜ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        queue = collections.deque([(root,0,-1)]) # èŠ‚ç‚¹ï¼Œæ·±åº¦ï¼Œçˆ¶äº²èŠ‚ç‚¹
        xy = []
        while queue:
            size = len(queue)
            for i in range(size):
                cur = queue.popleft()

                if cur[0].val in {x,y}:
                    xy.append((cur[1],cur[2]))
                    if len(xy) == 2: break
                
                if cur[0].left:
                    queue.append((cur[0].left,cur[1]+1,cur[0].val))
                if cur[0].right:
                    queue.append((cur[0].right,cur[1]+1,cur[0].val))
        
        # æ·±åº¦ç›¸åŒï¼Œçˆ¶äº²èŠ‚ç‚¹ç›¸åŒ
        return len(xy) == 2 and xy[0][1] != xy[1][1] and xy[0][0] == xy[1][0]
```



#### 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

>   ![image-20210810103417406](images/image-20210810103417406.png)

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        def helper(root,p,q):
            if not root: return
            if p.val == root.val or q.val == root.val: return root
            if p.val < root.val < q.val: return root
            if q.val < root.val: return helper(root.left,p,q)
            if p.val > root.val: return helper(root.right,p,q)
        if p.val > q.val:p,q = q,p
        return helper(root,p,q)
```





#### 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

>   $O(n)$ è§£æ³•

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        def helper(root,p,q):
            if root == p or root == q or not root: return root
            left = helper(root.left,p,q)
            right = helper(root.right,p,q)
            if not left and not right: return None
            if not left: return right
            if not right: return left
            return root
        
        return helper(root,p,q)
```

>   å€å¢LCA $O(\log n)$

é’ˆå¯¹çš„é—®é¢˜æ˜¯å¤§é‡æŸ¥è¯¢ï¼Œç”¨ç©ºé—´æ¢å–æ—¶é—´ï¼Œå…¶ä¸­ `father[root][i] = father[father[root][i-1]][i-1]` ç­‰ä»·äºï¼š
$$
2^i= 2^{i-1} + 2^{i-1}
$$
![image-20210906122320533](images/image-20210906122320533.png)

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        maxd = 20
        depth_dict = collections.defaultdict(int)
        # fa[u][i]ç»´æŠ¤çš„æ˜¯ç»“ç‚¹uå‘ä¸Šèµ°2 ^ iæ­¥åæ‰€åˆ°çš„ç»“ç‚¹
        father = collections.defaultdict(lambda :[0]*maxd)
        

        def dfs(root,pre,depth): # root è¡¨ç¤ºå½“å‰dfsèŠ‚ç‚¹ï¼Œpreè¡¨ç¤ºçˆ¶èŠ‚ç‚¹
            if not root: return 
            father[root][0] = pre # ç‰¹æ®Šåˆ¤æ–­
            depth_dict[root] = depth # è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦
            
            i = 1
            while depth_dict[root]-(1<<i) >= 0:
                # å½“å‰èŠ‚ç‚¹rootï¼Œå‘ä¸Šèµ°2^iæ­¥ --> 
                #        å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å‘ä¸Šèµ°2^(i-1)æ­¥
                father[root][i] = father[father[root][i-1]][i-1]
                i += 1

            dfs(root.left,root,depth+1)
            dfs(root.right,root,depth+1)


        def up(root,d): # å°†æ·±åº¦è¾ƒæ·±çš„é‚£ä¸ªèŠ‚ç‚¹æå‡ç›¸åŒæ·±åº¦
            if d == 0: return root
            for i in range(0,maxd):
                if (1<<i) & d: 
                    root = father[root][i]
            return root
                
        def lca(x,y):
            m = depth_dict[x] 
            n = depth_dict[y]
            if m > n:
                x,y = y,x
                m,n = n,m
            y = up(y,n-m) # promote y-val

            if x == y: return x

            for i in range(maxd-1,-1,-1):
                # ä»å¤§åˆ°å°
                if father[x][i] != father[y][i]:
                    x = father[x][i]
                    y = father[y][i]
            return father[x][0]
        
        dfs(root,None,0)
        return lca(p,q)
    
```



#### 1483. æ ‘èŠ‚ç‚¹çš„ç¬¬ K ä¸ªç¥–å…ˆ ğŸ‰

>   ![image-20211012182818339](images/image-20211012182818339.png)
>
>   åŸºæœ¬çš„æ€æƒ³è¿˜æ˜¯åˆ©ç”¨å€å¢ç®—æ³•ï¼Œ
>
>   Binary Lifting çš„æœ¬è´¨å…¶å®æ˜¯ dpã€‚$dp[node][j] $ å­˜å‚¨çš„æ˜¯ node èŠ‚ç‚¹è·ç¦»ä¸º 2^j çš„ç¥–å…ˆæ˜¯è°ã€‚
>
>   æ ¹æ®å®šä¹‰ï¼Œ$dp[node][0]$ å°±æ˜¯ $parent[node]$ï¼Œå³ node çš„è·ç¦»ä¸º 1 çš„ç¥–å…ˆæ˜¯ $parent[node]$ã€‚
>
>   çŠ¶æ€è½¬ç§»æ˜¯ï¼š $dp[node][j] = dp[dp[node][j - 1]][j - 1]$
>

```python
class Node:
    def __init__(self,val):
        self.val = val
        self.childs = list()

class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        self.n = n
        self.father = [[-1]*20 for i in range(n)]
        depth_dict = collections.defaultdict(int)
        
        def build_tree(parent):
            root = Node(0)
            node_map = {0:root}

            for i in range(1,n):
                node = Node(i)
                node_map[i] = node
            
            for i in range(1,n):
                node_map[parent[i]].childs.append(node_map[i])
            return root
        
        def helper(root,pre,depth):
            if not root: return None
            self.father[root.val][0] = pre.val if pre else -1 
            depth_dict[root] = depth

            # update
            i = 1
            while depth_dict[root]-(1<<i) >= 0:
                self.father[root.val][i] = self.father[self.father[root.val][i-1]][i-1]
                i += 1

            for child in root.childs:
                helper(child,root,depth+1)
            
        self.root = build_tree(parent)

        helper(self.root,None,0)

    def getKthAncestor(self, node: int, k: int) -> int:
        bit_arr = "{:b}".format(k)
        cur = node
        size = len(bit_arr)
        index = 0
        while index < size:
            if bit_arr[index] == "1":
                cur = self.father[cur][size-1-index]
            if cur == -1: break
            index += 1
        return cur




# Your TreeAncestor object will be instantiated and called as such:
# obj = TreeAncestor(n, parent)
# param_1 = obj.getKthAncestor(node,k)
```





#### 865. å…·æœ‰æ‰€æœ‰æœ€æ·±èŠ‚ç‚¹çš„æœ€å°å­æ ‘ ğŸ‰

>   ![image-20210810112604742](images/image-20210810112604742.png)
>
>   ä¸¤ç§æ€è·¯
>
>   +   ç¬¬ä¸€ç§æ€è·¯ã€‚é¦–å…ˆæ‰¾åˆ°è¿™äº›èŠ‚ç‚¹ï¼Œè¿™äº›èŠ‚ç‚¹éƒ½åœ¨åŒä¸€ä¸ªæ·±åº¦ä¸Šï¼Œé‚£ä¹ˆå‘ä¸Šéå†å³å¯ï¼Œç›´åˆ°æ‰€æœ‰èŠ‚ç‚¹éƒ½ç›¸åŒå³å¯ã€‚
>
>   +   ç¬¬äºŒç§æ€è·¯ï¼Œå’Œé€’å½’å½¢å¼çš„LCAç±»ä¼¼ï¼Œä¸€édfsæ‰¾åˆ°æœ€å¤§æ·±åº¦çš„èŠ‚ç‚¹ï¼Œç„¶åæŒ‰ç…§å››ç§æƒ…å†µåˆ¤æ–­å³å¯ã€‚
>   +   ç¬¬ä¸‰ç§æ€è·¯ï¼Œå°†ä¸Šé¢ä¸¤ç§æ··åˆèµ·æ¥ï¼Œå¾—åˆ°æœ€å¤§æ·±åº¦çš„èŠ‚ç‚¹ï¼Œè½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œç„¶ååˆ©ç”¨LCAæ¨¡æ¿

+   ç¬¬ä¸€ç§è§£æ³•ï¼š

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        self.max_depth = 0
        depth_dict = collections.defaultdict(int)
        def helper(root,pre,depth):
            if not root: return
            depth_dict[root] = depth
            self.max_depth = max(self.max_depth,depth)
            helper(root.left,root,depth+1)
            helper(root.right,root,depth+1)
        
        def answer(root): # é€šç”¨æ¨¡æ¿
            if not root or depth_dict[root] == self.max_depth: 
                return root
            left = answer(root.left)
            right = answer(root.right)
            if not left and not right: return None
            if not left: return right
            if not right: return left
            return root

        helper(root,None,0)
        return answer(root)
```



+   ç¬¬äºŒç§è§£æ³•

    ```python
    # Definition for a binary tree node.
    # class TreeNode:
    #     def __init__(self, val=0, left=None, right=None):
    #         self.val = val
    #         self.left = left
    #         self.right = right
    class Solution:
        def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
            self.max_depth = 0
            depth_dict = collections.defaultdict(list)
            def helper(root,pre,depth):
                if not root: return
                root.father = pre
                depth_dict[depth].append(root)
                self.max_depth = max(self.max_depth,depth)
                helper(root.left,root,depth+1)
                helper(root.right,root,depth+1)
            
            def check(dep_nodes):
                first = dep_nodes[0]
                for i in range(1,len(dep_nodes)):
                    if first.val != dep_nodes[i].val: return True
                return False
    
            helper(root,None,0)
            dep_nodes = depth_dict[self.max_depth]
            if len(dep_nodes) == 1: return dep_nodes[0]
    
    
            while check(dep_nodes): # å‘ä¸Šéå†
                for i in range(len(dep_nodes)):
                    dep_nodes[i] = dep_nodes[i].father
            
            return dep_nodes[0]
    ```

    +   ç¬¬ä¸‰ç§æ€è·¯

    ```python
    # Definition for a binary tree node.
    # class TreeNode:
    #     def __init__(self, val=0, left=None, right=None):
    #         self.val = val
    #         self.left = left
    #         self.right = right
    class Solution:
        def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
            self.max_depth = 0
            depth_dict = collections.defaultdict(list)
            def helper(root,pre,depth):
                if not root: return
                root.father = pre
                depth_dict[depth].append(root)
                self.max_depth = max(self.max_depth,depth)
                helper(root.left,root,depth+1)
                helper(root.right,root,depth+1)
    
            def answer(root): # é€šç”¨æ¨¡æ¿
                if not root or root in dep_nodes: 
                    return root
                left = answer(root.left)
                right = answer(root.right)
                if not left and not right: return None
                if not left: return right
                if not right: return left
                return root
    
            helper(root,None,0)
            dep_nodes = set(depth_dict[self.max_depth])
       
            return answer(root)
    ```

    

#### 987 äºŒå‰æ ‘çš„å‚åºéå† ğŸ‰

>   ![image-20210803215841110](images/image-20210803215841110.png)
>
>   æ€è·¯ï¼š
>
>   è®°å½•æ‰€æœ‰ç»“ç‚¹çš„åæ ‡ (x,y) ï¼Œç›¸åŒ x çš„ç»“ç‚¹æ”¾åœ¨åŒä¸€ä¸ªåˆ—è¡¨ã€‚
>
>   è¾“å‡ºæ—¶åˆ—è¡¨æŒ‰ x æ’åºã€‚åˆ—è¡¨ä¸­å…ˆæŒ‰ y æ’åºï¼Œæœ€åå†æŒ‰å€¼æ’åºå³å¯ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        queue = collections.deque([(root,0,0)])
        ans = []
        while queue:
            size = len(queue)
            for i in range(size):
                cur,x,y = queue.popleft()
                ans.append([x,y,cur.val])
                if cur.left:  queue.append((cur.left,x-1,y+1))
                if cur.right: queue.append((cur.right,x+1,y+1))
        ans.sort(key=lambda x:[x[0],x[1],x[2]])
        
        res = collections.OrderedDict()
        for val in ans:
            if val[0] in res:
                res[val[0]].append(val[2])
            else:
                res[val[0]] = [val[2]]

        return list(res.values())
```



## äºŒå‰æœç´¢æ ‘

#### 95.ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II & 96.ä¸åŒçš„äºŒå‰æœç´¢æ ‘ I & 108 å°†æœ‰åºæ•°ç»„è½¬æˆäºŒå‰æ ‘

+   95.  äºŒå‰æœç´¢æ ‘å¯ä»¥æœ‰å¾ˆå¤šä¸ªï¼Œä¸åŒçš„æ ¹å¯ä»¥ç”Ÿæˆä¸åŒçš„äºŒå‰æœç´¢æ ‘ã€‚éå†åŒºé—´ï¼Œå·¦è¾¹ç”Ÿäº§å·¦è¾¹æ ‘ï¼Œå³è¾¹ç”Ÿäº§å³è¾¹æ ‘ï¼Œç„¶åå¯¹ä¸¤è€…è¿›è¡Œæ‹¼æ¥ã€‚

```python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        def build(start,end):
            if start > end: return [None]
            if start == end: return [TreeNode(start)]
            
            ans = []
            for cur in range(start,end+1):
                left = build(start,cur-1)
                right = build(cur+1,end)

                for l in left: # left leaf value
                    for r in right: # right leaf value
                        root = TreeNode(cur)
                        root.left = l
                        root.right = r
                        ans.append(root)
            return ans
        
        return build(1,n)
```

+   96.  åœ¨Iä¸­éœ€è¦æ³¨æ„çš„æ˜¯[1,2]å’Œ[3,4]è¿™ä¸¤ä¸ªåŒºé—´èƒ½å¤Ÿå»ºé€ çš„äºŒå‰æœç´¢æ ‘çš„æ•°é‡æ˜¯ä¸€æ ·çš„ã€‚

    ![image-20210720173347480](images/image-20210720173347480-1626773629164.png)

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [1]*(n+1)
        for i in range(1,n+1):
            dp[i] = sum([dp[j]*dp[i-j-1] for j in range(i)])
        return dp[n]
```



#### å‰‘æŒ‡ Offer 33. äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ— ğŸ‰

>   æ€è·¯ï¼šè¿™ä¸€é¢˜æ˜¯åˆ¤æ–­æŸä¸ªåºåˆ—æ˜¯ä¸æ˜¯æŸä¸ªäºŒå‰æœç´¢æ ‘çš„çš„ååºéå†ã€‚æ‰©å±•é—®é¢˜å¯ä»¥æ˜¯åˆ¤æ–­æ˜¯ä¸æ˜¯æŸä¸ªäºŒå‰æœç´¢æ ‘çš„ä¸­åºå’Œå‰åºéå†ã€‚
>
>   ![image-20210720173551222](images/image-20210720173551222.png)

```python
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        def helper(start,end):
            if start >= end: return True
            p = start
            while postorder[p] < postorder[end]:
                p += 1
            m = p
            while postorder[p] > postorder[end]:
                p += 1
            return p == end and helper(start,m-1) and helper(m,end-1)
        
        return helper(0,len(postorder)-1)
```



#### å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨

>   `äºŒå‰æ ‘è½¬åŒ–ä¸ºé“¾è¡¨`
>
>   æ€è·¯ï¼šåŸºäºå¯¹äºŒå‰æ ‘è¿›è¡Œå˜æ¢ï¼Œä¸­åºéå†ä¸­ï¼Œåˆ©ç”¨ä¸‰ä¸ªæŒ‡é’ˆï¼Œ`self.head,self.prev,self.cur`æ¥åˆ†åˆ«è®°å½•äºŒå‰æ ‘çš„æœ€å·¦è¾¹ï¼Œä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»¥åŠå½“å‰èŠ‚ç‚¹ã€‚
>
>   ![image-20210720174436497](images/image-20210720174436497.png)

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return root
        # äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†
        self.prev = None
        self.head = None

        def dfs(root):
            if not root: return

            dfs(root.left)
            if not self.prev:
                self.head = root
            else:
                self.prev.right = root
                root.left = self.prev
            self.prev = root
            
            dfs(root.right)
        
        dfs(root)
        self.head.left = self.prev
        self.prev.right = self.head

        return self.head
```



#### 230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´  

æ€è·¯ï¼šé€’å½’æˆ–è€…è¿­ä»£æ–¹æ³•å‡å¯ã€‚è¿›é˜¶ç‰ˆé—®é¢˜ï¼Œå¦‚æœè¦é¢å¯¹å¤šä¸ªæŸ¥è¯¢å¦‚ä½•è§£å†³ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        # self.n = k
        # def helper(root):
        #     if not root: return None
            
        #     left = helper(root.left)
        #     if left is not None: return left
        #     self.n -= 1
        #     if self.n == 0: return root.val
        #     right = helper(root.right)
        #     if right is not None: return right
        # return helper(root)

        stack = []
        n = k
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            n -= 1
            if n == 0:
                return root.val
            root = root.right
```



#### 100 ç›¸åŒçš„æ ‘ & 101 å¯¹ç§°äºŒå‰æ ‘

100 éœ€è¦åˆ¤æ–­å››ç§æƒ…å†µï¼Œpå’Œqéƒ½ä¸ºç©ºï¼Œpä¸ºç©ºqä¸ä¸ºç©ºï¼Œpä¸ä¸ºç©ºqä¸ºç©ºï¼Œpå’Œqéƒ½ä¸ä¸ºç©ºã€‚å¯ä»¥åˆ©ç”¨é€’å½’æˆ–è€…é˜Ÿåˆ—å®ç°ã€‚

101 å’Œ100ç±»ä¼¼ï¼Œä¸è¿‡éœ€è¦åˆ¤æ–­å½“å‰æ ¹èŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹æ˜¯ä¸æ˜¯å¯¹ç§°çš„ã€‚å› æ­¤åŒæ ·æ˜¯ä¸Šé¢å››ç§æƒ…å†µï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å½“på’Œqéƒ½ä¸ä¸ºç©ºçš„æ—¶å€™ä¸”ç›¸ç­‰æ—¶å€™ï¼Œéœ€è¦åˆ¤æ–­å½“å‰å·¦å­æ ‘.leftå’Œå³å­æ ‘.rightï¼Œè¿™æ ·æ‰èƒ½å½¢æˆå¯¹ç§°åˆ¤æ–­ã€‚è¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨è¿­ä»£å®ç°ã€‚

+   100

![image-20210720181436034](images/image-20210720181436034-1626776077105.png)

```python
def helper(root):
    queue = [root,root]
    while queue:
        p = queue.pop(0)
        q = queue.pop(0)
        if not p and not q:
            continue
        elif not p or not q:
            return False
        else:
            if p.val != q.val:
            	return False
            # æ³¨æ„å‹å…¥æ ˆçš„é¡ºåº
            queue.append(p.left)
            queue.append(p.right)
            queue.append(q.right)
            queue.append(q.left)        
    return True
```

```python
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        def helper(p,q):
            if not p and not q: return True
            if not p or not q: return False
            return p.val == q.val and \
                    helper(p.left,q.left) and \
                    helper(p.right,q.right)
        return helper(p,q)
```



+   101

![image-20210720181410943](images/image-20210720181410943-1626776052113.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True
        def helper(p,q):
            if not p and not q: return True
            if not p or not q: return False
            return p.val == q.val and helper(p.left,q.right) and helper(p.right,q.left)
        
        return helper(root.left,root.right)
```



#### 173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨ ğŸ‰

>   æ€è·¯ï¼šåˆ©ç”¨æ ˆå®ç°ï¼Œå°†`while`å¾ªç¯ä¸­çš„stackå…¥æ ˆè¿‡ç¨‹æ‹†åˆ†å‡ºæ¥ã€‚

```python
class BSTIterator:
    def __init__(self, root: TreeNode):
        self.stack = []
        self.root = root
        self.helper()

    def helper(self):
        while self.root:
            self.stack.append(self.root)
            self.root = self.root.left
    
    def next(self) -> int:
        self.root = self.stack.pop()
        ans = self.root.val
        self.root = self.root.right
        self.helper()
        return ans
        
    def hasNext(self) -> bool:
        return not (len(self.stack) == 0)
```



#### 105 ä»å‰åºå’Œä¸­åºæ¢å¤äºŒå‰æ ‘ 106 ä»ä¸­åºååºæ¢å¤äºŒå‰æ ‘

å‰åºéå†çš„ç¬¬ä¸€ä¸ªå…ƒç´ å¯ä»¥å°†ä¸­åºéå†åˆ’åˆ†æˆå·¦å­æ ‘å’Œå³å­æ ‘ï¼Œä¸­åºéå†çš„å·¦å­æ ‘æ•°é‡å¯ä»¥ç¡®å®šå‰åºéå†ä¸‹ä¸€ä¸ªindexã€‚

+   å‰åº + ä¸­åº

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        inorder_dict = {inorder[i]:i for i in range(len(inorder))}

        def build(start,left,right): # include
            if left > right: return None

            mark = inorder_dict[preorder[start]]
            node = TreeNode(preorder[start])
            node.left = build(start+1,left,mark-1)
            node.right = build(start+(mark-left+1),mark+1,right)
            return node
        
        return build(0,0,len(inorder)-1)
```

+   ä¸­åº + ååº

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        inorder_dict = {inorder[i]:i for i in range(len(inorder))}
        def helper(start,end,idx):
            if start >= end or idx < 0: return None
            mark = inorder_dict[postorder[idx]]
            node = TreeNode(inorder[mark])
            node.right = helper(mark+1,end,idx-1)
            node.left = helper(start,mark,idx-(end-mark))
            return node
        return helper(0,len(inorder),len(inorder)-1)
```

+   å‰åº + ååº

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:
        post_dict = {post[i]:i for i in range(len(post))}

        def helper(s1,e1,s2,e2):
            if s1 > e1: return None
            if s1 == e1: return TreeNode(pre[s1])
            cur = TreeNode(pre[s1])

            val = pre[s1+1]
            r2_post_idx = post_dict[val] # [4,5,2] 2çš„idx
            len = r2_post_idx - s2 + 1

            cur.left = helper(s1+1,s1+len,s2,r2_post_idx)
            cur.right = helper(s1+len+1,e1,r2_post_idx+1,e2-1)
            return cur
        
        return helper(0,len(pre)-1,0,len(post)-1)
```





#### 104æ ‘çš„æœ€å¤§æ·±åº¦ & 110 å¹³è¡¡äºŒå‰æ ‘ & 111$\leftarrow$ äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ & 543 äºŒå‰æ ‘ç›´å¾„ & 124 äºŒå‰æ ‘æœ€å¤§è·¯å¾„å’Œ

+   104  æ ‘çš„æœ€å¤§æ·±åº¦

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root: return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

+   110 å¹³è¡¡äºŒå‰æ ‘

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def helper(root):
            if not root: return 0
            left = helper(root.left)
            right = helper(root.right)
            if left < 0 or right < 0: return -1
            if abs(left-right) > 1:
                return -1
            
            return max(left,right)+1
        
        return helper(root) >= 0
```



111 äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ è¿™ä¸€é¢˜å¾ˆå…·æœ‰è¿·æƒ‘æ€§ï¼ŒäºŒå‰æ ‘çš„æ·±åº¦é™¤äº†å¯ä»¥ç”¨é€’å½’æ–¹æ³•æ¥åšï¼Œè¿˜å¯ä»¥ç”¨è¿­ä»£çš„æ–¹æ³•æ¥åšï¼Œå¹¶ä¸”é€Ÿåº¦ä¸ä¼šæ›´æ…¢ã€‚åœ¨åˆ©ç”¨é€’å½’æ–¹æ³•æ±‚è§£æ—¶ï¼Œéœ€è¦æ³¨æ„æ ¹èŠ‚ç‚¹ä¸ºç©ºå’Œå¶å­èŠ‚ç‚¹çš„å¤„ç†ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root: return 0
        def helper(root):
            if not root: return float("inf")
            if not root.left and not root.right: return 1
            left = helper(root.left)
            right = helper(root.right)
            return min(left,right) + 1
        return helper(root)
```



124 æœ€å¤§è·¯å¾„å’Œä¹‹ç±»çš„é—®é¢˜éœ€è¦æ³¨æ„çš„æ˜¯è´Ÿæ•°é—®é¢˜ï¼Œå¦‚æœä¸€ä¸ªrootçš„è·¯å¾„å’Œï¼ˆä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ï¼‰ä¸èƒ½å¤§äº0ï¼Œé‚£ä¹ˆè¿™ä¸ªå­æ ‘å¯ä»¥è¢«å®Œå…¨æŠ›å¼ƒã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œï¼ˆ**è®¡ç®—çš„ç»“æœ**ï¼‰å’Œï¼ˆ**è¿”å›çš„ç»“æœ**ï¼‰æ˜¯ä¸¤ä¸ªä¸åŒçš„æ¦‚å¿µã€‚

![image-20210720195610862](images/image-20210720195610862.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.ans = float("-inf")
        def helper(root):
            if not root: return 0
            left = helper(root.left)
            right = helper(root.right)
            self.ans = max(self.ans,max(right,0)+max(left,0)+root.val)
            return max(max(left,right),0) + root.val
        helper(root)
        return self.ans
```



#### 112 è·¯å¾„æ€»å’Œ å’Œ 113 è·¯å¾„æ€»å’ŒII å’Œ 437. è·¯å¾„æ€»å’Œ III ğŸ‰

+   113 è·¯å¾„æ€»å’Œ

![image-20210720200422391](images/image-20210720200422391-1626782663987.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        self.ans = []
        def helper(root,target,path):
            if not root: return 
            if not root.left and not root.right and target == root.val:
                self.ans.append(path[:] + [target])
            
            helper(root.left,target-root.val,path + [root.val])
            helper(root.right,target-root.val,path + [root.val])
        helper(root,targetSum,[])
        return self.ans
```

+   437 è·¯å¾„æ€»å’Œ

>   å‰ç¼€å’Œ + å“ˆå¸Œè¡¨

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        self.hash_set = collections.defaultdict(int)
        self.hash_set[0] = 1 # é¢„å…ˆè®¾ç½®
        self.ans = 0

        def helper(root,pre_sum):
            if not root: return
            pre_sum += root.val
            self.ans += self.hash_set.get(pre_sum-targetSum,0)

            self.hash_set[pre_sum] += 1
            helper(root.left,pre_sum)
            helper(root.right,pre_sum)
            self.hash_set[pre_sum] -= 1
        
        helper(root,0)
        return self.ans
            
```



#### 297 äºŒå‰æ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ– 

æ€è·¯ï¼šå¯ä»¥é‡‡ç”¨`DFS`æˆ–è€…`BFS`ï¼Œå¦‚æœè¦æ±‚å°½å¯èƒ½å‡å°‘å­˜å‚¨ç©ºé—´å‘¢ï¼Ÿæ¯”å¦‚æœ€åé¢çš„`None`å¯ä»¥åˆ é™¤ã€‚

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root: return "[]"
        queue = collections.deque([root])
        data = []
        while queue:
            cur = queue.popleft()
            if not cur: 
                data.append("none")
            else:
                data.append(str(cur.val))
                queue.append(cur.left)
                queue.append(cur.right)  
        
        i = len(data)-1
        while data[i] == "none":
            i -= 1
        return "[" + ",".join(data[:i+1]) + "]" 

        
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if len(data) == 2: return None
        data = data[1:-1].split(",")
        
        idx = 0
        root = TreeNode(data[idx])
        queue = collections.deque([root]) # è¿™é‡Œåº”è¯¥æ˜¯ä¸ªé˜Ÿåˆ—
        while queue:
            cur = queue.popleft() # popleft
            idx += 1
            if idx >= len(data) or data[idx] == "none":
                cur.left = None
            else:
                cur.left = TreeNode(data[idx])
                queue.append(cur.left)
            
            idx += 1
            if idx >= len(data) or data[idx] == "none":
                cur.right = None
            else:
                cur.right = TreeNode(data[idx])
                queue.append(cur.right)
            

        return root


# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
```



## æ ‘èŠ‚ç‚¹è¿›è¡Œå¢åˆ æ”¹æ“ä½œ

#### 114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

æ€è·¯ï¼šè¿™ä¸€é¢˜å’Œ`å‰‘æŒ‡ Offer 36`æœ€å¤§çš„åŒºåˆ«åœ¨äº`å‰‘æŒ‡ Offer 36`è¦æ±‚ä¸­åºéå†ï¼Œè€Œè¿™ä¸€é¢˜è¦æ±‚å‰åºéå†ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œå¦‚æœè¦æ±‚ååºéå†å‘¢ï¼Ÿ

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.prev = None
        self.head = None

        def helper(root):
            if not root: return 

            left = root.left
            right = root.right
            if not self.prev:
                self.head = root
                self.prev = root
            else:
                self.prev.right = root
                self.prev.left = None
                self.prev = root

            helper(left)
            helper(right)
        
        helper(root)
        return self.head
```



#### [116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/) ğŸ‰

>   ![image-20211011200643431](images/image-20211011200643431.png)
>
>   ç¬¬ä¸€ç§é€’å½’è§£å†³æ–¹æ³•ï¼š
>
>   <img src="images/eef065800417742831e8702ef7b45ccb082afa3782470af81491d2b4b6046f40-5.gif" alt="5.gif" style="zoom:50%;" />
>
>   ç¬¬äºŒç§é€’å½’æ€è·¯ï¼š
>
>   ```python
>   """
>   # Definition for a Node.
>   class Node:
>       def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
>           self.val = val
>           self.left = left
>           self.right = right
>           self.next = next
>   """
>   
>   class Solution:
>       def connect(self, root: 'Node') -> 'Node':
>           """ å‰ææ˜¯å®Œç¾äºŒå‰æ ‘ """
>           def helper(root):
>               if not root or not root.left: return root
>               root.left.next = root.right
>               if root.next:
>                   root.right.next = root.next.left
>               helper(root.left)
>               helper(root.right)
>   
>           helper(root)
>           return root
>               
>   ```









#### 99 æ¢å¤äºŒå‰æœç´¢æ ‘

å…³é”®ç‚¹åœ¨äºå®šä¹‰ä¸¤ä¸ªmistakeå˜é‡ï¼Œç”¨æ¥è®°å½•ä¸¤ä¸ªè¢«ç½®æ¢çš„å˜é‡ã€‚ç„¶åè¿›è¡Œä¸­åºéå†

```python
mistake1,mistake2 = None,None
pre = None
def dfs(root):
    if not root: return
    dfs(root.left)
    if not pre:
        pre = root
    else:
        if pre.val > root.val:
            mistake1 = pre
            mistake2 = root
        else:
            mistake2 = root
            return
        pre = root
    dfs(root.right)
mistake1.val,mistake2.val = mistake2.val,mistake1.val
```



#### 538. æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘

æ€è·¯ï¼šè€ƒè™‘å½“å‰çš„ä¸€æ£µæ ‘ï¼Œåº”è¯¥è€ƒè™‘å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å·²ç»ç´¯ç§¯äº†å¤šå°‘æ•°

```python
def helper(root,val):
    if not root: return val
    r = helper(root.right,val)
    root.val += r
    l = helper(root.left,root.val)
    return l
```



#### 669. ä¿®å‰ªäºŒå‰æœç´¢æ ‘

>   æ€è€ƒï¼šè€ƒè™‘æŸä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå½“å‰ `root.val<low`ï¼Œè¯´æ˜å½“å‰çš„`root`å’Œå·¦è¾¹çš„å­æ ‘éƒ½åº”è¯¥è¢«åˆ é™¤ï¼›å¦‚æœå½“å‰`root.val>high`ï¼Œåˆ™è¯´æ˜å½“å‰çš„rootå’Œå³è¾¹çš„å­æ ‘éƒ½åº”è¯¥è¢«åˆ é™¤ã€‚è¿™ä¸€é¢˜åº”è¯¥åŒæ ·æ€è€ƒåˆ°`98. éªŒè¯äºŒå‰æœç´¢æ ‘`ï¼Œè§TODO-listã€‚
>
>   ![image-20210722151712496](images/image-20210722151712496-1626938234873.png)



```python
# ç¬¬ä¸€ç§æƒ…å†µï¼ŒæŠ›å¼ƒroot.valå’Œroot.left
	       root.val
          /         \
root.left            root.right
                     [low    high]
    
# ç¬¬äºŒç§æƒ…å†µï¼ŒæŠ›å¼ƒroot.valå’Œroot.right
               root.val
              /         \
    root.left            root.right
[low    high]
```

```python
class Solution:
    def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
        def helper(root,low,high):
            if not root: return None
            if root.val > high:
                return helper(root.left,low,high)
            elif root.val < low:
                return helper(root.right,low,high)
            else:
                root.left = helper(root.left,low,root.val)
                root.right = helper(root.right,root.val,high)
                return root
        
        return helper(root,low,high)
```



#### 938. äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ

![image-20210720204221610](images/image-20210720204221610-1626784942936.png)

æ€è·¯ï¼šè¿™ä¸€é¢˜å’Œ669ç±»ä¼¼ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        def helper(root,low,high):
            if not root: return 0
            if root.val > high:
                return helper(root.left,low,high)
            if root.val < low: 
                return helper(root.right,low,high)

            left = helper(root.left,low,high)
            right = helper(root.right,low,high)
            return left + right + root.val
        
        return helper(root,low,high)
```



#### 897 é€’å¢é¡ºåºæœç´¢æ ‘

é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½  **æŒ‰ä¸­åºéå†** å°†å…¶é‡æ–°æ’åˆ—ä¸ºä¸€æ£µé€’å¢é¡ºåºæœç´¢æ ‘ï¼Œä½¿æ ‘ä¸­æœ€å·¦è¾¹çš„èŠ‚ç‚¹æˆä¸ºæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­èŠ‚ç‚¹ï¼Œåªæœ‰ä¸€ä¸ªå³å­èŠ‚ç‚¹ã€‚

![img](E:\git\typora\LeetCodeåˆ·é¢˜\images\ex2.jpg)

```python
class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        self.prev = None
        self.head = None

        def helper(root):
            if not root: return

            helper(root.left)

            if self.prev == None:
                self.head = root
                self.prev = root
            else:
                root.left = None
                self.prev.right = root
                self.prev = root
            
            helper(root.right)
        
        helper(root)
        return self.head
```



#### 1110. åˆ ç‚¹ä¸ºæ—

>   æ€è·¯ï¼šæ˜ç¡®é€’å½’ä¸‰æ¡ä»¶ã€‚
>
>   ![image-20210720204414325](images/image-20210720204414325-1626785055525.png)

```python
class Solution:
    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:
        to_delete = set(to_delete)
        self.ans = []
        def helper(root):
            if not root: return None
            
            root.left = helper(root.left) # æ­£å¸¸åœ°å‘å·¦è¾¹éå†
            root.right = helper(root.right) # æ­£å¸¸åœ°å‘å³è¾¹éå†

            if root.val in to_delete: # å¦‚æœåœ¨å¾…åˆ é™¤åœ°èŠ‚ç‚¹ä¸­ï¼Œå°†å·¦è¾¹å’Œå³è¾¹çš„èŠ‚ç‚¹åŠ å…¥ç»“æœä¸­
                if root.left: self.ans.append(root.left)
                if root.right: self.ans.append(root.right)
                return None # è¿”å›Noneè¡¨ç¤ºåˆ é™¤å½“å‰èŠ‚ç‚¹
            else:
                return root # è¿”å›rootè¡¨ç¤ºä¸åˆ é™¤ï¼Œè€Œæ­£å¸¸è¿›è¡Œ

        root = helper(root)
        if root: self.ans.append(root)
        return self.ans
```



#### 450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

>    æ€è·¯ï¼šåˆ é™¤äºŒå‰æœç´¢æ ‘å¿…ç„¶æ¶‰åŠåˆ°å¯¹äºŒå‰æ ‘èŠ‚ç‚¹çš„è°ƒæ•´ï¼Œä¸ºäº†å®ç°è¿™æ ·çš„åŠŸèƒ½ï¼Œæœ€é‡è¦çš„ä¸€ä¸ªæ­¥éª¤å°±æ˜¯è¿›è¡Œmost_rightæˆ–è€…most_leftçš„æ“ä½œã€‚
>
>    ![image-20210722144507777](images/image-20210722144507777.png)
>
>    ![450.jpg](images/1611932922-MelojG-450.jpg)



```python
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        def helper(root,key):
            if not root: return None
            if root.val > key: 
                root.left = helper(root.left,key)
            elif root.val < key:
                root.right = helper(root.right,key)
            else:
                if not root.left and not root.right: return None
                if not root.left: return root.right
                if not root.right: return root.left
                node = root.right
                while node.left:
                    node = node.left
                node.left = root.left
                root = root.right
            return root
        
        return helper(root,key)
```



#### 124 äºŒå‰æ ‘æœ€å¤§è·¯å¾„å’Œ & 543 äºŒå‰æ ‘æœ€å¤§ç›´å¾„

æ€è·¯ï¼šè¿™ä¸¤é¢˜çš„åŸºæœ¬æ€è·¯ä¸€è‡´ï¼Œä¸€ä¸ªå…¨å±€å˜é‡è®°å½•å½“å‰æœ€å¤§å€¼ï¼Œè¿”å›åˆ°ä¸Šä¸€å±‚æ˜¯å½“å‰å•å‘è·¯å¾„çš„æœ€å¤§å€¼

```python
def helper(root):
    if not root: return 0
    left = helper(root,left)
    right = helper(root.right)
    max_val = max(left+right+1,max_val)
    return max(left,right)+1

def helper(root):
    if not root: return 0
    left = helper(root,left)
    right = helper(root.right)
    max_val = max(left+right+root.val,max_val)
    return max(max(left,right)+root.val,0)    
```



##  åŒ/å¤šé‡é€’å½’

#### 572. å¦ä¸€ä¸ªæ ‘çš„å­æ ‘ ğŸ‰

æ€è·¯ï¼šåŒé‡æœç´¢ï¼Œä¸€ä¸ªdfséå†æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åä¸€ä¸ªé€’å½’ï¼Œåˆ¤æ–­ä¸¤ä¸ªå­æ ‘æ˜¯å¦ç›¸åŒã€‚èƒ½ä¸èƒ½æœ‰æ›´å¥½çš„è§£æ³•ï¼Œæœ‰ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ï¼Œç„¶ååˆ¤æ–­å­ä¸²æ˜¯å¦å­˜åœ¨ã€‚

```python
class Solution(object):

    def isSubtree(self, s, t):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        def ser(root):
            if not root:    
                return '#'
            st=' '+str(ser(root.left))+' '+str(ser(root.right))+' '+str(root.val)+' ' #å‰ååŠ ç©ºæ ¼ï¼Œé¿å…[12][1]çš„æƒ…å†µè¯¯åˆ¤
            return st
        
        return ser(t) in ser(s)
```



#### 863. äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸º K çš„ç»“ç‚¹ ğŸ‰

>    æ€è·¯ï¼šæ ‘è½¬å›¾

```python
class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        from collections import defaultdict
        self.visited = defaultdict(lambda: False)
        def dfs(root):
            if not root: return
            self.visited[root] = False
            if root.left: root.left.parent = root
            if root.right: root.right.parent = root
            dfs(root.left)
            dfs(root.right)
            return root
        
        root.parent = None
        dfs(root)

        k = K
        ans = []
        queue = [target]
        self.visited[target] = True
        while queue:
            size = len(queue)
            k -= 1
            for i in range(size):
                curr = queue.pop(0)
                if k == -1: 
                    ans.append(curr.val)
                    continue
                for next_point in [curr.parent,curr.right,curr.left]:
                    if (next_point is not None) and (not self.visited[next_point]):
                        self.visited[next_point] = True
                        queue.append(next_point)
        return ans
```



[j]:
